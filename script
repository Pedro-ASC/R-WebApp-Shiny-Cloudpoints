# App Shiny: Diagnóstico e Tratamento de Nuvens de Pontos LiDAR

options(shiny.maxRequestSize = 500 * 1024^2)
library(sf)
library(shiny)
library(lidR)
library(rgl)
library(DT)
library(shinyBS) 
library(raster)
library(RMCC)
library(leaflet)
library(shinyalert)
library(shinycssloaders)

##########
#Interface
##########

ui <- fluidPage(
  tags$style(HTML("
    .panel-group {
      max-width: 100%;
    }
    .panel-title > a {
      display: block;
      padding: 6px 12px;
      font-weight: bold;
      text-decoration: none;
      color: #2c3e50;
    }
    .panel-title > a:hover {
      text-decoration: underline;
    }
      .plot-border {
    border: 1px solid black;
    border-radius: 5px;
    padding: 5px;
    box-sizing: border-box;
    max-width: 100%;
  }
  ")),
  titlePanel("Diagnóstico e Processamento de Nuvens de Pontos"),
  sidebarLayout(
    sidebarPanel(
      
      #########################
      #Aba Diagnóstico Sidebar#      
      #########################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Diagnóstico'",
        fileInput("lasfile", "Carregue um arquivo .las/.laz", 
                  accept = c(".las", ".laz")),
        hr(),
        
        actionButton("limpar_classificacao", "Limpar Classificação"),
        hr(),
        
        h4("Estrutura padrão de arquivos .las"),
        tags$a("LAS Specification 1.4 - R15", href = "#", 
               onclick = "window.open('https://www.asprs.org/wp-content/uploads/2019/07/LAS_1_4_r15.pdf', '_blank'); return false;"),
        bsCollapse(id = "explicacoes_las", open = NULL,
                   bsCollapsePanel("X, Y, Z ▼", HTML("<ul><li>Coordenadas espaciais do ponto no espaço.</li>
                                              <li>Valores de X e Y menores que 1000 tendem a indicar sistemas de coordenada local.</li>
                                              <li>bbox = bounding box (caixa em torno da nuvem de pontos).</li>
                                              <li>'Scale Factor' e 'Offset Value' são valores utilizados para correção de coordenadas reduzidas.</li></ul>")),
                   bsCollapsePanel("Intensity ▼", HTML("<ul><li>Valor que representa a magnitude do retorno do pulso, ou seja, quanto do pulso foi refletido de volta pro sensor.</li>
                                                   <li>Superfícies mais reflexivas tendem a gerar valores maiores.</li></ul>")),
                   bsCollapsePanel("ReturnNumber ▼", HTML("<ul><li>Número sequencial do retorno para aquele pulso.</li>
                                                      <li>Cada vez que o pulso atravessa uma superfície e retorna ao sensor.</li></ul>")),
                   bsCollapsePanel("NumberOfReturns ▼", HTML("<ul><li>Número total de retornos detectados para aquele pulso.</li></ul>")),
                   bsCollapsePanel("ScanDirectionFlag ▼", HTML("<ul><li>Utilizado para equipamentos com scanner rotativo.
                                                           <ul><li>1 <- Scanner voltado para a esquerda em relação à direção do vôo</li>
                                                           <li>0 <- Scanner voltado para a direita (ou quando o equipamento não for rotativo).</li></ul></li></ul>")),
                   bsCollapsePanel("EdgeOfFlightline ▼", HTML("<ul><li>Marca pontos oriundos da borda (edge) do scanemento com valor '1'.</li>
                                                              <li>Recebe o valor 0 quando não está na borda ou não é compatível com o equipamento (Ex: Scanner 360°)</li></ul>")),
                   bsCollapsePanel("ScanAngleRank ▼", HTML("<ul><li>Ângulo do feixe de escaneamento no momento da medição.</li>
                                                       <li>Recebe valores de -90 a 90 graus.</li></ul>")),
                   bsCollapsePanel("Classification ▼", HTML("<ul><li>Classe atribuída ao ponto. Exemplos:
                                                        <ul><li>0 ou 1 <- Não classificado</li>
                                                        <li>2 <- Chão</li>
                                                        <li>3, 4 ou 5 <- Vegetação</li>
                                                        <li>7 ou 18 <- Ruído</li></ul></li></ul>")),
                   bsCollapsePanel("UserData ▼", HTML("<ul><li>Campo de uso livre destinado ao usuário.</li></ul>")),
                   bsCollapsePanel("PointSourceID ▼", HTML("<ul><li>Identificador temporal da origem do ponto.</li>
                                                       <li>Vôos diferentes, por exemplo, tem PointSourceID diferentes.</li>")),
                   bsCollapsePanel("GPS Time ▼", HTML("<ul><li>Instante exato em que o pulso foi emitido.</li>
                                                  <li>Medido a partir do tempo base do sistema GPS.</li></ul>")),
                   bsCollapsePanel("RGB ▼", HTML("<ul><li>Valores das bandas Vermelho, Verde e Azul associadas ao ponto.</li></ul>"))
        )
      ),
      
      #####################################
      #Aba Classificação de Ruídos Sidebar#
      #####################################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Classificação de ruídos'",
        
        h4("Algoritmo de classificação"),
        radioButtons("algoritmo_ruidos", label = NULL,
                     choices = c("SOR" = "sor", "IVF" = "ivf"),
                     selected = "sor"),
        
        h4("Parâmetros"),
        uiOutput("parametros_ruidos"),
        
        checkboxInput("mostrar_naoruidos", "Mostrar pontos não ruído", 
                      value = TRUE),
        fluidRow(
          column(6,
                 selectInput("cor_ruidos", "Cor pontos ruído",
                             choices = c("Verde" = "green", "Azul" = "blue", 
                                         "Vermelho" = "red", "Amarelo" = "yellow"),
                             selected = "green")
          ),
          column(6,
                 selectInput("cor_nao_ruidos", "Cor pontos não ruído:",
                             choices = c("RGB" = "rgb", "Cinza" = "gray","Preto" = "black",
                                         "Azul" = "blue","Amarelo" = "yellow"),
                             selected = "rgb"))
        ),
        
        actionButton("classificar_ruidos", "Classificar"),
        hr(),
        
        actionButton("aplicar_classificacao", "Salvar classificação"),
        actionButton("aplicar_classificacao_s_r", "Excluir ruídos"),
        
        hr(), 
        
        h4("Sobre os algoritmos"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 24 'Classify points'"),
        bsCollapse(id = "explicacoes_algoritmos_ruidos", open = NULL,
                   
                   bsCollapsePanel("SOR (Statistical Outliers Removal) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
                        <li>Calcula a distância média e desvio padrão de 'k' pontos de todos os pontos da nuvem.</li>
                        <li>Qualquer ponto com distância média maior que o limite é classificado como ruído</li>
                        <li>Se 'quantile' igual 'Não', então:
                        <ul><li>limite = distância média + ('m' * desvio padrão)</li></ul></li>
                        <li>Se 'quantile' igual 'Sim', então:
                        <ul><li>limite = quantile(distâncias, probs = 'm')</li>
                        <li>Ou seja, 'm' se torna um limite quantilico</li></ul></li>
                        </ul></span>")),
                   bsCollapsePanel("IVF (Isolated Voxels Filter) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
                        <li>A nuvem de pontos é dividida em voxels cúbicos com lado igual a 'res'.</li>
                        <li>Para cada ponto é calculado quantos outros pontos estão presentes nos 26 voxels ao redor mais o voxel que contém o ponto.(3x3x3)</li>
                        <li>Se o número de pontos total (nos 27 voxels) for menor que 'n' então o ponto em questão é considerado ruído.</li>
                        </ul></span>")))
      ),
      
      ###################################
      #Aba Classificaçao do chao Sidebar#     
      ###################################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Classificação do chão'",
        
        h4("Algoritmo de classificação"),
        radioButtons("algoritmo_solo", label = NULL,
                     choices = c("CSF" = "csf", "PMF" = "pmf", "MCC" = "mcc"),
                     selected = "csf"),
        
        h4("Parâmetros"),
        uiOutput("parametros_algo"),
        
        checkboxInput("mostrar_outros", "Mostrar pontos não chão", value = TRUE),
        
        fluidRow(
          column(6,
                 selectInput("cor_chao", "Cor pontos chão:",
                             choices = c("Verde" = "green", "Azul" = "blue", 
                                         "Vermelho" = "red", "Amarelo" = "yellow"),
                             selected = "green")
          ),
          column(6,
                 selectInput("cor_nao_chao", "Cor pontos não chão:",
                             choices = c("RGB" = "rgb",
                                         "Cinza" = "gray","Preto" = "black",
                                         "Azul" = "blue","Amarelo" = "yellow"),
                             selected = "rgb"))
        ),
        
        actionButton("classificar_solo", "Classificar"),
        hr(),
        
        actionButton("aplicar_classificacao", "Salvar classificação"),
        hr(),
        
        h4("Sobre os algoritmos"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 24 'Classify points'"),
        bsCollapse(id = "explicacoes_algoritmos", open = NULL,
                   
                   bsCollapsePanel("CSF (Cloth Simulation Filter) ▼", HTML("<span style='font-size:smaller;'><ul>
    <li>Simula um 'pano' (grid) caindo sobre os pontos da nuvem, que se ajusta ao terreno e ajuda a identificar o solo.</li>
    <li>Os pontos são classificados de acordo com sua distância à posição do grid simulado</li>
    <li>É robusto em terrenos irregulares e vegetação densa.</li>
    <li><strong>Parâmetros</strong>:
    <ul><li><em>sloop_smoth</em>: Lógico. Aplica correção para terrenos íngremes.</li>
    <li><em>class_threshold</em>: Numérico. Distância máxima entre o ponto e o 'pano' para ser classificado.</li>
    <li><em>cloth_resolution</em>: Numérico. Distância entre os nós da malha (grid) do 'pano'.</li>
    <li><em>rigidness</em>: Inteiro. Controla a rigidez com que o 'pano' dobra. Quanto mais flexível mais o nó do grid se deslocará até o próximo ponto. (Lembre-se: O 'pano' está caindo)
      <ul><li>1 : 'Pano' flexível</li>
          <li>2 : Médio</li>
          <li>3 : Rígido</li></ul></li>
    <li><em>iterations</em>: Inteiro. Valor padrão. Máximo de iterações na simulação do 'pano'.</li>
    <li><em>time_step</em>: Numérico. Valor padrão. Passo do deslocamento vertical descendente (queda).</li></ul> 
  </ul>
  <p><a href='https://www.mdpi.com/2072-4292/8/6/501' target='_blank'>Zhang et al., 2016</a></p>
  </span>")),
                   
                   bsCollapsePanel("PMF (Progressive Morphological Filter) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
    <li>Baseado em operações morfológicas aplicadas progressivamente para remover vegetação e preservar o solo.</li>
    <li>Ou seja, cria-se uma janela que cresce linear ou exponencialmente, suaviza a superfície e
        calcula a diferença entre o ponto original e a superfície estimada.</li>
    <li>Se a distância entre o ponto original e a superfície é menor que o threshold, então é classificado como chão.</li>
    <li>É adequado para áreas planas e topografia simples.</li>
    <li>É sensível à escolha do tamanho da janela e a distância aceitável entre ponto e superfície.</li>
    <li><strong>Parâmetros</strong>:
    <ul><li><em>Windows size(ws)</em>: Numérico. Sequência de valores. Área da janela na unidade de medida da nuvem.</li>
    <li><em>Threshold (th)</em>: Numérico. Sequência de valores (de tamanho igual ao ws). Distância máxima entre superfície e ponto na unidade de medida da nuvem</li></ul>
    <li>Os parâmetros podem ser calculados pela função 'util_makeZhangParam' disponível em lidR.</ul>
    <p><a href='https://www.researchgate.net/publication/3203162_A_progressive_morphological_filter_for_removing_nonground_measurements_from_airborne_LIDAR_data' 
      target='_blank'>Zhang et al., 2013</a></p><span>")),
                   
                   bsCollapsePanel("MCC (Multiscale Curvature Classification) ▼", 
                                   HTML("<span style='font-size:smaller;'<ul>
    <li>Utiliza a curvatura local em múltiplas escalas para distinguir pontos de solo e vegetação.</li>
    <li>Funciona bem em áreas com relevo acidentado.</li>
    <li>Opção quando CSF e PMF não funcionam bem, mas é mais lento por envolver análise multiescala.</li>
    <li><strong>Parâmetros</strong>:
    <ul><li><em>Scale parameter (s)</em>: Numérico. Define o tamanho da janela que avalia a curvatura. Pontos de nuvem mais densos o 's' deve ser menor, nuvens mais esparsas 's' maior.</li>
    <li><em>Curvature threshold (t)</em>: Numérico. Valor máximo de curvatura para ser considerado chão.</li></ul>
  </ul>
    <p><a href='https://www.researchgate.net/publication/3204849_A_Multiscale_Curvature_Algorithm_for_Classifying_Discrete_Return_LiDAR_in_Forested_Environments'
      target='_blank'>Evans, Jeffrey S.; Hudak, Andrew T. 2007.</a></p></span>")))
        
      ),
      
      ##########################
      #Aba Normalização Sidebar#      
      ##########################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Normalização'",
        
        h4("Algoritmo para criação do MDT"),
        radioButtons("algoritmo_mdt", label = NULL,
                     choices = c("IDW" = "idw","TIN" = "tin"),
                     selected = "idw"),
        
        h4("Parâmetros"),
        uiOutput("parametros_mdt"),
        
        actionButton("gerar_mdt", "Gerar MDT"),
        hr(),
        
        actionButton("aplicar_normalizacao", "Aplicar normalização"),
        hr(),
        
        h4("Sobre os algoritmos"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 34 'dtm_*'"),
        bsCollapse(id = "explicacoes_algoritmos_norm", open = NULL,
                   bsCollapsePanel("Modelo Digital do Terreno (MDT) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Representação matemática e digital da superfície do solo, ou seja, exclui-se objetos sobre o mesmo.</li>
        <li>Raster onde cada célula contém a altitude do terreno naquele ponto.</li>
        <li>Resolução da malha (grid) = medida do lado do pixel.</li>
        <li>É gerado a partir de pontos classificados como chão ('2')</li>
                          </ul></span>")),
                   bsCollapsePanel("Normalização ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Geralmente a altura ('Z') dos pontos são calculados em altitude acima do nível médio do mar.</li>
        <li>A normalização recalcula essa altitude para absoluta, ou seja, em relação ao terreno.</li>
        <li>Z<i>normalizado</i> = Z<i>original</i> - Z<i>terreno</i></li>
        <li>Facilita a retirada de métricas.</li>
                          </ul></span>")),
                   bsCollapsePanel("IDW (Inverse Distance Weighting) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Este algoritmo é composto por dois modelos: KNN e IDW.</li>
        <li>KNN = K-Nearest Neighbour = Procura os 'k' pontos chão mais próximos de todos os pontos chão da nuvem.</li>
        <li>IDW = Inverse Distance Weighting = Calcula a média ponderada da distância do ponto até os 'k' pontos e dá mais peso aos pontos mais próximos.</li>
        <li>No fim cada célula do raster do MDT receberá um valor que representa a superfície contínua do terreno.</li>
        <li><strong>Parâmetros</strong>:</li>
        <ul><li><em>k</em>: Inteiro. Número de pontos vizinhos.</li>
        <li><em>p</em>: Numérico. Expoente da ponderação da distância inversa.</li>
        <li><em>rmax</em>: Numérico. Raio máximo de busca dos 'k' vizinhos.</li></ul>
                          </ul></span>")),
                   bsCollapsePanel("TIN (Triangulated Irregular Network) ▼",
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Usa a Triangulação de Delaunay sobre os pontos chão com interpolação linear.</li>
        <li>Triangulação de Delaunay = Os pontos são os vértices do triângulo. Garante que nenhum outro ponto, fora os vértices, estejam dentro do
        circulo circunstrito ao triângulo.</li>
        <li>Interpolação linear = Método matemático que estima uma valor desconhecido entre dois pontos conectado-os com uma linha reta.</li>
        <li>A limitação deste algoritmo se encontra nas bordas da nuvem de pontos, onde podem sobrar pontos que não fecham triângulos. Quando isso acontece é possível usar o parâmetro
        'extrapolate' que usa o algoritmo IDW para preencher o que resta.</li>
        <li>Não há parâmetros para esse algoritmo.</li>
                        </ul></span>")),
                   bsCollapsePanel("Kriging (Krigagem Universal) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Método complexo e avançado de interpolação espacial.</li>
        <li>Krigagem = Interpolação geoestatística baseada na dependência espacial entre os dados.</li>
        <li>Universal = Assume que a média não é constante na área mas que varia segundo uma tendência.</li>
        <li>Usa um variograma ajustado para estimar a semelhança entre os pontos em função da distância.</li>
        <li>Em conjunto com o variograma utiliza a abordagem KNN (já explicada em IDW)</li>
        <li>Ou seja, para cada ponto de interesse faz a krigagem do terreno usando o 'k' pontos mais próximos.</li>
        <li>Devido à necessidade de ajustar um variograma se faz necessário que a aplicação deste modelo aconteça fora deste aplicativo.</li>
                       </ul></span>"))
        )
      )
    ),
    
    mainPanel(
      tabsetPanel(id = "aba_ativa",
                  
                  ##########################
                  #Aba Diagnostico Mainpanel                  
                  ##########################
                  
                  tabPanel("Diagnóstico",
                           verbatimTextOutput("diag_info")),
                  
                  ##################################
                  #Aba Classificaçao Ruido Mainpanel
                  ##################################
                  
                  tabPanel("Classificação de ruídos",
                           div(class = "plot-border", 
                               withSpinner(rglwidgetOutput("plot_ruidos",
                                               width = "100%", height = "600px"), 
                                           type = 6, color = "green")),
                           br(),
                           h4("Diagnósticos dos pontos ruído"),
                           uiOutput("diag_ruidos")
                  ),
                  
                  #################################
                  #Aba Classificacao Chão Mainpanel
                  #################################
                  
                  tabPanel("Classificação do chão",
                           div(class = "plot-border", 
                               withSpinner(rglwidgetOutput("plot_mdt", 
                                               width = "100%", height = "600px"), 
                                           type = 6, color = "green")),
                           br(),
                           h4("Diagnóstico dos pontos chão"),
                           uiOutput("diag_solo_classificado")
                  ),
                  
                  ############################
                  #Aba Normalização Mainpanel#
                  ############################
                  
                  tabPanel("Normalização",
                           withSpinner(rglwidgetOutput("plot_mdtn", 
                                                       height = "600px"), 
                                       type = 6, color = "green"))
      )
    )
  )
)

#########
#Servidor
#########

server <- function(input, output, session) {
  lasData <- reactiveVal(NULL)
  lasSoloClassificado <- reactiveVal(NULL)
  lasRuidos <- reactiveVal(NULL)
  mdt <- reactiveVal(NULL)
  
  ################
  #Aba Diagnóstico
  ################
  
  #Input  
  observeEvent(input$lasfile, {
    req(input$lasfile)
    las <- readLAS(input$lasfile$datapath)
    lasData(las)
  })
  
  output$arquivo_status <- renderPrint({
    if (!is.null(lasData())) {
      cat("Arquivo carregado com sucesso.")
    } else {
      cat("Nenhum arquivo carregado.")
    }
  })
  
  observeEvent(input$limpar_classificacao, {
    req(lasData())
    las <- lasData()
    las$Classification <- as.integer(0)
    lasData(las)
    
    shinyalert(
      title = "Classificação limpa!",
      type = "success",
      timer = 1500,
      showConfirmButton = FALSE
    )
  })
  
  output$diag_info <- renderPrint({
    req(lasData())
    
    withProgress(message = "Carregando diagnóstico...", value = 0, {
      
      las <- lasData()
      header <- las@header
      ladox <- (header@PHB$`Max X` - header@PHB$`Min X`)
      ladoy <- (header@PHB$`Max Y` - header@PHB$`Min Y`)
      area_bbox <- ladox * ladoy
      alt_bbox <- (header@PHB$`Max Z` - header@PHB$`Min Z`)
      xscale <- header@PHB$`X scale factor`
      yscale <- header@PHB$`Y scale factor`
      zscale <- header@PHB$`Z scale factor`
      xoffset <- header@PHB$`X offset`
      yoffset <- header@PHB$`Y offset`
      zoffset <- header@PHB$`Z offset`
    
    # Verifica agrupamento dos pontos de solo por desvio padrão da densidade
    solo <- filter_poi(las, Classification == 2)
    if (npoints(solo) > 0) {
      dens_grid <- grid_density(solo, res = 1)
      dens_sd <- sd(values(dens_grid), na.rm = TRUE)
    } else {
      dens_sd <- NA
    }
    
    # Verificação de normalização com base na mediana de Z do solo
    if (npoints(solo) > 0) {
      mediana_z_solo <- median(solo@data$Z, na.rm = TRUE)
      esta_normalizada <- abs(mediana_z_solo) <= 0.5
    } else {
      mediana_z_solo <- NA
      esta_normalizada <- NA
    }
    
    cat("### XYZ ### \n")
    
    # Diagnóstico CRS
    crs_info <- sf::st_crs(las)
    if (!is.na(crs_info$epsg)) {
      cat("Sistema de Coordenadas:", crs_info$epsg, "-", crs_info$Name, "\n")
    } else {
      cat("Sistema de Coordenadas:", crs_info$proj4string, "\n")
    }
    
    # Verificação da escala das coordenadas
    med_x <- mean(las@data$X, na.rm = TRUE)
    if (abs(med_x) < 166000) {
      cat("Média da coordenada X < 166 mil: Sistema local ou reduzido.\n")
    }
    
    # Diagnóstico sobre Intensity
    tem_intensity <- "Intensity" %in% names(las@data) &&
      mean(!is.na(las@data$Intensity) & las@data$Intensity > 0, na.rm = TRUE) > 0.95
    
    # Diagnóstico sobre retornos
    tem_return_number <- "ReturnNumber" %in% names(las@data) &&
      mean(!is.na(las@data$ReturnNumber) & las@data$ReturnNumber > 0) > 0.95
    tem_number_of_returns <- "NumberOfReturns" %in% names(las@data) &&
      mean(!is.na(las@data$NumberOfReturns) & las@data$NumberOfReturns > 0) > 0.95
    
    # Diagnóstico sobre RGB
    tem_rgb_valido <- all(c("R", "G", "B") %in% names(las@data)) &&
      mean(rowSums(las@data[, c("R", "G", "B")]) > 0, na.rm = TRUE) > 0.95
    
    simulado_rgb <- FALSE
    if (tem_rgb_valido) {
      rgb_vals <- las@data[, c("R", "G", "B")]
      geom_vars <- las@data[, c("X", "Y", "Z")]
      cors <- cor(cbind(geom_vars, rgb_vals), use = "complete.obs")
      cor_geom_rgb <- cors[c("X", "Y", "Z"), c("R", "G", "B")]
      simulado_rgb <- any(abs(cor_geom_rgb) > 0.85)
    }
    
    # Verificação de classificação
    if ("Classification" %in% names(las@data)) {
      classes_presentes <- unique(na.omit(las@data$Classification))
      esta_classificada <- length(classes_presentes) > 1
      tem_chao_classificado <- 2 %in% classes_presentes
    } else {
      esta_classificada <- FALSE
      tem_chao_classificado <- FALSE
    }
    
    cat("Total de pontos:", npoints(las), "\n")
    cat("Lado X bbox (m):", round(ladox, 2), "\n")
    cat("Lado Y bbox (m):", round(ladoy, 2), "\n")
    cat("Área bbox (m²):", round(area_bbox, 2), "\n")
    cat("Altura Z bbox (m):", round(alt_bbox, 2), "\n")
    cat("Scale Factor:", xscale, yscale, zscale, "\n")
    cat("Offset Value:", xoffset, yoffset, zoffset, "\n")
    cat("Mínimo e Máximo de X:", header@PHB$`Min X`, header@PHB$`Max X`, "\n")
    cat("Mínimo e Máximo de Y:", header@PHB$`Min Y`, header@PHB$`Max Y`, "\n")
    cat("Mínimo e Máximo de Z:", header@PHB$`Min Z`, header@PHB$`Max Z`, "\n \n")
    
    cat("### Intensity ### \n")
    cat("Válido?", if (tem_intensity) "Sim" else "Não", "\n")
    cat("Mínimo e Máximo:", min(las@data$Intensity), max(las@data$Intensity), "\n \n")
    
    cat("### Return Number e Number Of Returns ### \n")
    cat("ReturnNumber válido?", if (tem_return_number) "Sim" else "Não", "\n")
    cat("NumberOfReturns válido?", if (tem_number_of_returns) "Sim" else "Não", "\n")
    cat("Máximo de retornos:", max(las@data$ReturnNumber), "\n")
    cat("Pontos por retorno:", header@PHB$`Number of points by return`, "\n \n")
    
    # Verificações de ScanDirectionFlag, EdgeOfFlightLine e ScanAngleRank
    tem_scan_direction <- "ScanDirectionFlag" %in% names(las@data) && any(las@data$ScanDirectionFlag != 0, na.rm = TRUE)
    tem_edge_flag <- "EdgeOfFlightline" %in% names(las@data) && any(las@data$EdgeOfFlightline != 0, na.rm = TRUE)
    tem_scan_angle <- "ScanAngleRank" %in% names(las@data) && any(las@data$ScanAngleRank != 0, na.rm = TRUE)
    
    cat("### Scan Direction Flag ### \n")
    cat("Válido?", if (tem_scan_direction) "Sim" else "Não", "\n")
    cat("Quantos pontos 0 e 1?", sum(las@data$ScanDirectionFlag == 0), sum(las@data$ScanDirectionFlag == 1), "\n \n")
    
    cat("### Edge Of Flightline ### \n")
    cat("Válido?", if (tem_edge_flag) "Sim" else "Não", "\n")
    cat("Quantos pontos 0 e 1?",sum(las@data$EdgeOfFlightline == 0), sum(las@data$EdgeOfFlightline == 1), "\n \n")
    
    cat("### Scan Angle Rank ### \n")
    cat("Válido?", if (tem_scan_angle) "Sim" else "Não", "\n")
    cat("Mínimo e Máximo:", min(las@data$ScanAngleRank), max(las@data$ScanAngleRank), "\n \n")
    
    cat("### Classification ### \n")
    cat("Pontos classificados? ", if (esta_classificada) "Sim" else "Não", "\n")
    cat("Quais classes? ", unlist(classes_presentes), "\n")
    
    # Estatísticas sobre pontos classificados como chão (2)
    if (esta_classificada) {n_chao <- npoints(solo)
    dens_chao <- if (!is.null(n_chao) && area_bbox > 0) n_chao / area_bbox else NA
    cat("Pontos classificados como chão:", n_chao, "\n")
    cat("Densidade de pontos no chão (pontos/m²):", round(dens_chao, 2), "\n")
    cat("Desvio-padrão da densidade de pontos no chão:", if (!is.na(dens_sd)) round(dens_sd, 2) else "Não aplicável", "\n")
    cat("Mediana Z do solo (m):", if (!is.na(mediana_z_solo)) round(mediana_z_solo, 2) else "Não aplicável", "\n")
    cat("Nuvem normalizada? ", 
        if (is.na(esta_normalizada)) "Não aplicável \n" 
        else if (esta_normalizada) "Sim" else "Não", "\n \n")} else {cat("\n")}   
    
    # Diagnóstico PointSourceID: número de fontes distintas
    if ("PointSourceID" %in% names(las@data)) {
      fontes_id <- unique(na.omit(las@data$PointSourceID))
      qtd_fontes <- length(fontes_id)
    } else {
      qtd_fontes <- NA
    }
    
    # UserData
    tem_userdata <- "UserData" %in% names(las@data) && any(!is.na(las@data$UserData) & las@data$UserData != 0)
    cat("### UserData ### \n")
    cat("Preenchido?", if (tem_userdata) "Sim" else "Não", "\n")
    if (tem_userdata) {cat("Mínimo e Máximo:", min(las@data$UserData), max(las@data$UserData), "\n \n")} else {cat("\n")}
    
    # Verificação GPSTime
    tem_gpstime <- "gpstime" %in% names(las@data) &&
      mean(!is.na(las@data$gpstime) & las@data$gpstime > 0, na.rm = TRUE) > 0.95
    
    cat("### Point Source ID ### \n")
    if (!is.na(qtd_fontes)) {
      if (qtd_fontes > 1) {
        cat("PointSourceID: ", qtd_fontes, " fontes diferentes \n \n")
      } else {
        cat("PointSourceID: Apenas uma fonte \n \n")
      }
    } else {
      cat("PointSourceID: Coluna ausente \n \n")
    }
    cat("### GPS Time ### \n")
    cat("Válido?", if (tem_gpstime) "Sim" else "Não", "\n \n")
    
    # RGB
    cat("### RGB ### \n")
    cat("Possui RGB?", if (tem_rgb_valido) "Sim" else "Não", "\n")
    if (tem_rgb_valido) {cat("RGB parece simulado?", if (simulado_rgb) "Sim" else "Não", "\n")}
    })
  })
  
  #########################
  #Aba Classificação ruido#
  #########################
  output$parametros_ruidos <- renderUI({
    req(input$algoritmo_ruidos)
    
    if (input$algoritmo_ruidos == "sor") {
      fluidRow(
        column(6,
               numericInput("k", "Número de vizinhos (k)", value = 10),
               numericInput("m", "Multiplicador/Quantil (m)", value = 3)),
        column(6,
               selectInput("quantile", "Quantílico", 
                           choices = c("Sim" = TRUE, "Não" = FALSE), selected = FALSE))
      )
    } else if (input$algoritmo_ruidos == "ivf") {
      fluidRow(
        column(6,
               numericInput("res", "Resolução dos voxels (res)", value = 3)),
        column(6,
               numericInput("n", "Limite (n)", value = 5))
      )
    }
  })
    
  observeEvent(input$classificar_ruidos, {
    req(lasData())
    las <- lasData()
    
    if (input$algoritmo_ruidos == "sor") {
      las_ruidos <- classify_noise(
        las,
        sor(
          k = input$k,
          m = input$m,
          quantile = as.logical(input$quantile)
        )
      )
    } else if (input$algoritmo_ruidos == "ivf") {
      las_ruidos <- classify_noise(
        las,
        ivf(
          res = input$res,
          n = input$n
        )
      )
    }
    lasRuidos(las_ruidos)
  })
  
  output$plot_ruidos <- renderRglwidget({
    req(lasRuidos())
    
    las <- lasRuidos()
    ruidos <- filter_poi(las, Classification == 18)
    nao_ruidos <- filter_poi(las, Classification != 18)
    bbox <- apply(las@data[, c("X", "Y", "Z")], 2, range)
    xlim <- bbox[,"X"]
    ylim <- bbox[,"Y"]
    zlim <- bbox[,"Z"]
    
    open3d()
    bg3d("white")
    par3d(windowRect = c(100, 100, 800, 800))
    
    cor_ruidos <- input$cor_ruidos
    
    if (input$mostrar_naoruidos && npoints(nao_ruidos) > 0) {
      tem_rgb <- all(c("R", "G", "B") %in% names(nao_ruidos@data))
      
      if (input$cor_nao_ruidos == "rgb" && tem_rgb) {
        rgb_mat <- nao_ruidos@data[, c("R", "G", "B")]
        max_rgb <- max(rgb_mat, na.rm = TRUE)
        divisor <- if (max_rgb > 255) 65535 else 255
        cores <- rgb(rgb_mat$R / divisor, rgb_mat$G / divisor, rgb_mat$B / divisor)
        plot3d(nao_ruidos@data[, c("X", "Y", "Z")], col = cores, size = 1, 
               add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
      } else {
        plot3d(nao_ruidos@data[, c("X", "Y", "Z")], col = input$cor_nao_ruidos, 
               size = 1, add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
      }
      
    } else {
      
      plot3d(ruidos@data[, c("X", "Y", "Z")], col = cor_ruidos, size = 1, 
             add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
      nao_ruidos <- NULL
    }
    
    if (npoints(ruidos) > 0 && !is.null(nao_ruidos)) {
      points3d(ruidos@data[, c("X", "Y", "Z")], col = cor_ruidos, size = 1)
    }
    
    rglwidget()
  })
  
  output$diag_ruidos <- renderUI({
    req(input$aba_ativa == "Classificação de ruídos")
    req(lasRuidos())
    
    ruidos <- filter_poi(lasRuidos(), Classification == 18)
    if (npoints(ruidos) == 0) return(tags$div("Nenhum ponto classificado como ruído."))
    
    # Estatísticas básicas
    total <- npoints(ruidos)
    perc <- (total / npoints(lasRuidos())) * 100
    perc_formatado <- sprintf("%.2f%%", perc)
    
    fluidRow(
      column(6,
             strong("Total de pontos:"), br(), total, br(), br()
      ),
      column(6,
             strong("Percentual:"), br(), perc_formatado, br(), br()
      )
    )
  })

  
  observeEvent(input$aplicar_classificacao, {
    req(lasRuidos())
    lasData(lasRuidos())
    
    shinyalert(
      title = "Classificação salva!",
      type = "success",
      timer = 1500,
      showConfirmButton = FALSE
    )
  }) 
  
  observeEvent(input$aplicar_classificacao_s_r, {
    req(lasRuidos())
    las_sem_ruido <- filter_poi(lasRuidos(), Classification != 18)
    lasData(las_sem_ruido)
    
    shinyalert(
      title = "Ruídos excluídos!",
      type = "success",
      timer = 1500,
      showConfirmButton = FALSE
    )
  })
  
  #######################      
  #Aba Classificação Chão
  #######################
  
  output$parametros_algo <- renderUI({
    req(input$algoritmo_solo)
    
    if (input$algoritmo_solo == "csf") {
      fluidRow(
        column(6,
               selectInput("sloop_smooth", "sloop_smooth", choices = c("Sim" = TRUE, "Não" = FALSE), selected = FALSE),
               numericInput("class_threshold", "class_threshold", value = 0.5, step = 0.1),
               numericInput("cloth_resolution", "cloth_resolution", value = 0.5, step = 0.1)
        ),
        column(6,
               selectInput("rigidness", "rigidness", choices = c(1, 2, 3), selected = 1),
               numericInput("iterations", "iterations", value = 500, min = 1, step = 1),
               numericInput("time_step", "time_step", value = 0.65, step = 0.01)
        )
      )
    } else if (input$algoritmo_solo == "pmf") {
      fluidRow(
        column(6,
               textInput("pmf_ws", "Tamanho Janela (ws)",
                         value = "3,6,9,12")
        ),
        column(6,
               textInput("pmf_th", "Limite (th)",
                         value = "0.1,0.3,0.5,1")
        )
      )
    } else if (input$algoritmo_solo == "mcc") {
      fluidRow(
        column(6,
               textInput("mcc_s", "Tamanho da janela (s)",
                         value = 1.5)),
        column(6,
               textInput("mcc_t", "Limite de curvatura (t)",
                         value = 0.3))
      )
    }
  })
  
  parse_seq <- function(txt) {
    vals <- unlist(strsplit(txt, "[,;\\s]+"))   # aceita vírgula, ponto-e-vírgula ou espaços
    vals <- trimws(vals)
    vals <- vals[vals != ""]
    nums <- as.numeric(vals)
    if (any(is.na(nums))) stop("Sequência contém valores não numéricos")
    nums
  }
    
  observeEvent(input$classificar_solo, {
    req(lasData())
    las <- lasData()
    
    if (input$algoritmo_solo == "csf") {
      
      las_classificado <- classify_ground(
        las,
        csf(
          sloop_smooth = as.logical(input$sloop_smooth),
          class_threshold = input$class_threshold,
          cloth_resolution = input$cloth_resolution,
          rigidness = as.integer(input$rigidness),
          iterations = as.integer(input$iterations),
          time_step = input$time_step
        )
      )
      
    } else if (input$algoritmo_solo == "pmf") {
      
      ws_vals <- tryCatch(parse_seq(input$pmf_ws),
                          error = function(e) { showNotification(paste("Erro em ws:", e$message), type = "error"); return(NULL) })
      if (is.null(ws_vals)) return()
      
      th_vals <- tryCatch(parse_seq(input$pmf_th),
                          error = function(e) { showNotification(paste("Erro em th:", e$message), type = "error"); return(NULL) })
      if (is.null(th_vals)) return()
      
      # se o usuário forneceu apenas 1 threshold, repetir para cada ws
      if (length(th_vals) == 1) {
        th_vals <- rep(th_vals, length(ws_vals))
      }
      
      if (length(th_vals) != length(ws_vals)) {
        showNotification("Número de thresholds deve ser 1 ou igual ao comprimento de ws.", type = "error")
        return()
      }
      
      las_classificado <- classify_ground(las, pmf(ws = ws_vals, th = th_vals))
    } else if (input$algoritmo_solo == "mcc") {
      las_classificado <- classify_ground(
        las, mcc(
          s = as.numeric(input$mcc_s),
          t = as.numeric(input$mcc_t)
        )
      )
    }
    lasSoloClassificado(las_classificado)
  })
  
  output$plot_mdt <- renderRglwidget({
    req(lasSoloClassificado())
    
    las <- lasSoloClassificado()
    ground <- filter_poi(las, Classification == 2)
    not_ground <- filter_poi(las, Classification != 2)
    
    bbox <- apply(las@data[, c("X", "Y", "Z")], 2, range)
    xlim <- bbox[,"X"]
    ylim <- bbox[,"Y"]
    zlim <- bbox[,"Z"]
    
    open3d()
    bg3d("white")
    par3d(windowRect = c(100, 100, 800, 800))
    
    cor_chao <- input$cor_chao
    
    if (input$mostrar_outros && npoints(not_ground) > 0) {
      
      tem_rgb <- all(c("R", "G", "B") %in% names(not_ground@data))
      
      if (input$cor_nao_chao == "rgb" && tem_rgb) {
        rgb_mat <- not_ground@data[, c("R", "G", "B")]
        max_rgb <- max(rgb_mat, na.rm = TRUE)
        divisor <- if (max_rgb > 255) 65535 else 255
        cores <- rgb(rgb_mat$R / divisor, rgb_mat$G / divisor, rgb_mat$B / divisor)
        plot3d(not_ground@data[, c("X", "Y", "Z")], col = cores, size = 1, 
               add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
      } else {
        plot3d(not_ground@data[, c("X", "Y", "Z")], col = input$cor_nao_chao, 
               size = 1, add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
      }
      
    } else {
      
      plot3d(ground@data[, c("X", "Y", "Z")], col = cor_chao, size = 1, 
             add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
      not_ground <- NULL
    }
    
    if (npoints(ground) > 0 && !is.null(not_ground)) {
      points3d(ground@data[, c("X", "Y", "Z")], col = cor_chao, size = 1)
    }
    
    rglwidget()
  })
  
  
  output$diag_solo_classificado <- renderUI({
    req(input$aba_ativa == "Classificação do chão")
    req(lasSoloClassificado())
    
    solo <- filter_poi(lasSoloClassificado(), Classification == 2)
    if (npoints(solo) == 0) return(tags$div("Nenhum ponto classificado como chão."))
    
    # Estatísticas básicas
    total <- npoints(solo)
    zmax <- max(solo@data$Z, na.rm = TRUE)
    zmin <- min(solo@data$Z, na.rm = TRUE)
    amplitude <- zmax - zmin
    
    # Cálculo da densidade e seu desvio padrão
    dens <- grid_density(solo, res = 1)
    media <- mean(values(dens), na.rm = TRUE)
    desvio <- sd(values(dens), na.rm = TRUE)
    
    fluidRow(
      column(6,
             strong("Total de pontos:"), br(), total, br(), br(),
             strong("Z máx:"), br(), round(zmax, 2), br(), br(),
             strong("Z mín:"), br(), round(zmin, 2)
      ),
      column(6,
             strong("Amplitude Z:"), br(), round(amplitude, 2), br(), br(),
             strong("Média/m²:"), br(), round(media, 2), br(), br(),
             strong("Desvio/m²:"), br(), round(desvio, 2)
      )
    )
  })
  
  observeEvent(input$aplicar_classificacao, {
    req(lasSoloClassificado())
    lasData(lasSoloClassificado())
    
    shinyalert(
      title = "Classificação salva!",
      type = "success",
      timer = 1500,
      showConfirmButton = FALSE
    )
  })
  
  ##################      
  #Aba Normalização#
  ##################
  
  output$parametros_mdt <- renderUI({
    req(input$algoritmo_mdt)
    
    if(input$algoritmo_mdt == "idw") {
      tagList(
      numericInput("res", "Resolução da malha (grid)", value = 1, step = 1),
      fluidRow(
        column(6,
               numericInput("k", "Número de vizinhos (k)", value = 10, step = 1),
               numericInput("p", "Expoente (p)", value = 2, step = 1)),
        column(6,
               numericInput("rmax", "Raio máximo (rmax)", value = 50, step = 1))
      )
    )
    } else if (input$algoritmo_mdt == "tin") {
      tagList(
        numericInput("res", "Resolução da malha (grid)", value = 1, step = 1),
        radioButtons("alterar_extrap", "Alterar parâmetros da Extrapolação?",
                     choices = c("Sim", "Não"), selected = "Não"),
        
        conditionalPanel(
          condition = "input.alterar_extrap == 'Sim'",
          fluidRow(
            column(6,
                   numericInput("k", "Número de vizinhos (k)", value = 3, step = 1),
                   numericInput("p", "Expoente (p)", value = 2, step = 1)),
            column(6,
                   numericInput("rmax", "Raio máximo (rmax)", value = 50, step = 1))
          )
        )
      )
    }
  })
    
  observeEvent(input$gerar_mdt, {
    req(lasData())
    las <- lasData()
    
    if (input$algoritmo_mdt == "idw") {
      
      mdt <- grid_terrain(las,
                          res = input$res,
                          knnidw(k = as.integer(input$k),
                                 p = input$p,
                                 rmax = input$rmax))
    } else if (input$algoritmo_mdt == "tin" & input$alterar_extrap == "Não") {
      
      mdt <- grid_terrain(las,
                          res = input$res,
                          tin())
    } else if (input$algoritmo_mdt == "tin" & input$alterar_extrap == "Sim") {
      
      mdt <- grid_terrain(las,
                          res = input$res,
                          tin(extrapolate = knnidw(k = as.integer(input$k),
                                                     p = input$p,
                                                     rmax = input$rmax)))
    }
    mdt(mdt)
  })
      
  output$plot_mdtn <- renderRglwidget({
    req(mdt())
    plot_dtm3d(mdt(), bg = "white")
    rglwidget()
  })

}

shinyApp(ui, server)
