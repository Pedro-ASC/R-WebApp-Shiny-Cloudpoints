##################################################
## ProcessaLAS: Análise e Processamento Inicial ## 
## de Nuvens de Pontos LiDAR                    ##
## versão 1.0                                   ##
##################################################
## Criado por: Pedro A. S. C.                   ##
## Contato: pedroasoresc@gmail.com              ##
##################################################

options(shiny.maxRequestSize = 500 * 1024^2) #Altera o limite de tamanho de update.
options(rgl.useNULL = TRUE)

library(sf)
library(shiny)
library(lidR)
library(rgl)
library(DT)
library(shinyBS) 
library(raster)
library(RMCC)
library(leaflet)
library(shinyalert)
library(shinycssloaders)
library(plotly)
library(rlas)

##########
#Interface
##########

ui <- fluidPage(
  tags$style(HTML("
    .panel-group {
      max-width: 100%;
    }
    .panel-title > a {
      display: block;
      padding: 6px 12px;
      font-weight: bold;
      text-decoration: none;
      color: #2c3e50;
    }
    .panel-title > a:hover {
      text-decoration: underline;
    }
      .plot-border {
    border: 1px solid black;
    border-radius: 5px;
    padding: 5px;
    box-sizing: border-box;
    max-width: 100%;
  }
  ")),
  titlePanel(" "),
  sidebarLayout(
    sidebarPanel(
      
      ################
      #Início Sidebar#      
      ################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Início'",
        h2("Painel Lateral", style = "text-align: center;"),
        h6("Aqui é realizada a entrada de arquivos, valores e configurações que serão usados no processamento."),
        
        hr(),
        
        h4("Você encontrará:"),
      
        hr(), 
        
        fileInput("ex_tutorial", "Entrada da Nuvem de pontos:", 
                  placeholder = "Ex: nuvem_projeto_01.las/.laz",
                  buttonLabel = "Procurar...") %>% 
          tagAppendAttributes(style = "pointer-events: none; opacity: 1;"),
        helpText(HTML("Carregue a nuvem de pontos que será processada.
                 <br>Limite máximo sugerido: 512 MB"),
                 style = "margin-top: -30px;"),
        
        hr(),
        
        actionButton("ex_tutorial", "Botão de Ação"),
        span(
          icon("info-circle"), 
          id = "ajuda_tutorial", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_tutorial", 
          title = "Breve explicação.",
          placement = "right", 
          trigger = "hover"
        ),
        helpText(HTML("Executará algum processamento. Pode demorar.
                 <br>Revise os parâmetros e configurações antes de clicar.")),
        
        hr(),
        
        checkboxInput("ex_tutorial", "Caixa de seleção."),
        helpText(HTML("Selecionada é Verdadeiro (TRUE)."),
                 style = "margin-top: -15px;"),
        
        hr(),
        
        downloadButton("ex_tutorial", "Botão de Download") %>%
                       tagAppendAttributes(style = "pointer-events: none; opacity: 1;"),
        helpText(HTML("Faz o download da última nuvem de pontos salva no aplicativo.")),
        hr(),
        
        bsCollapse(id = "ex_tutorial", open = NULL,
                   bsCollapsePanel("Seção de ajuda ▼", 
                   HTML("<ul><li>Informação resumida e relevante.</li></ul>"))
        ),
        helpText(HTML("Clique."), style = "margin-top: -5px")
      ),
      
      #########################
      #Aba Análise Sidebar#      
      #########################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Análise'",
        
        h4("Carregue a Nuvem de pontos"),
        fileInput("lasfile", "",accept = c(".las", ".laz"), 
                  buttonLabel = "Procurar...",
                  placeholder = ".las/.laz") %>% 
          tagAppendAttributes(style = "margin-top: -15px;"),
        
        hr(),
        
        h4("Análise"),
        actionButton("gerar_diag", "Gerar"),
        span(
          icon("info-circle"), 
          id = "ajuda_diag", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_diag", 
          title = "Geração de métricas de todos os atributos de um arquivos .las/.laz.",
          placement = "right", 
          trigger = "hover"
        ),
        
        hr(),
        
        h4("Classificação"),
        actionButton("limpar_classificacao", "Zerar"),
        span(
          icon("info-circle"), 
          id = "ajuda_class", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_class", 
          title = "Atribui o valor zero (nunca classificado) no atributo Classification para todos os pontos.",
          placement = "right", 
          trigger = "hover",
          options = list(container = "body")
        ),
        
        hr(),
        
        h4("Download"),
        checkboxInput("comprimir", "Comprimir (.laz)", value = TRUE),
        downloadButton("salvar_las_d", ""),
        hr(),
        
        h4("Índice Espacial (.lax)"),
        fileInput("arquivo_las", "Selecione o caminho de uma nuvem de pontos", accept = c(".las", ".laz"),
                  buttonLabel = "Procurar...",
                  placeholder = ".las/.laz"),
        actionButton("gerar_lax", "Criar"),
        span(
          icon("info-circle"), 
          id = "ajuda_lax", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_lax", 
          title = "Cria um arquivo LAX a partir do endereço de qualquer arquivo LAS/LAZ. A nuvem selecionada não ocupa memória.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Ajuda"),
        bsCollapse(id = "explicacoes_las", open = NULL,
                   bsCollapsePanel("X, Y, Z ▼", HTML("<ul><li>Coordenadas espaciais do ponto no espaço.</li>
                                              <li>Valores de X e Y menores que 1000 tendem a indicar sistemas de coordenada local.</li>
                                              <li>bbox = bounding box (caixa delimitadora em torno da nuvem de pontos).</li>
                                              <li>'Scale Factor' e 'Offset Value' são valores utilizados para correção de coordenadas reduzidas com o intuinto de economizar espaço.</li></ul>")),
                   bsCollapsePanel("Intensity ▼", HTML("<ul><li>Valor que representa a magnitude do retorno do pulso, ou seja, quanto do pulso foi refletido de volta pro sensor.</li>
                                                   <li>Menores distâncias, superfícies mais reflexivas e ângulos de incidência perpendiculares do pulso laser tendem a gerar valores maiores.</li></ul>")),
                   bsCollapsePanel("ReturnNumber ▼", HTML("<ul><li>Número sequencial do retorno para aquele pulso.</li>
                                                      <li>Cada vez que o pulso atravessa uma superfície e retorna ao sensor.</li></ul>")),
                   bsCollapsePanel("NumberOfReturns ▼", HTML("<ul><li>Quantidade total de retornos detectados para aquele pulso.</li></ul>")),
                   bsCollapsePanel("ScanDirectionFlag ▼", HTML("<ul><li>Utilizado para equipamentos com scanner rotativo.
                                                           <ul><li>1 <- Scanner voltado para a esquerda em relação à direção do vôo</li>
                                                           <li>0 <- Scanner voltado para a direita (ou quando o equipamento não for rotativo).</li></ul></li></ul>")),
                   bsCollapsePanel("EdgeOfFlightline ▼", HTML("<ul><li>Marca pontos oriundos da borda (edge) do scanemento com valor '1'.</li>
                                                              <li>Recebe o valor 0 quando não está na borda ou não é compatível com o equipamento (Ex: Scanner 360°)</li></ul>")),
                   bsCollapsePanel("ScanAngleRank ▼", HTML("<ul><li>Ângulo do feixe de escaneamento no momento da medição.</li>
                                                       <li>Recebe valores de -90 a 90 graus.</li></ul>")),
                   bsCollapsePanel("Classification ▼", HTML("<ul><li>Classe atribuída ao ponto.</li> 
                                                        <li>Exemplos:
                                                        <ul><li>0 ou 1 <- Não classificado</li>
                                                        <li>2 <- Chão</li>
                                                        <li>3, 4 ou 5 <- Vegetação</li>
                                                        <li>7 ou 18 <- Ruído</li></ul></li></ul>")),
                   bsCollapsePanel("UserData ▼", HTML("<ul><li>Campo de uso livre destinado ao usuário.</li></ul>")),
                   bsCollapsePanel("PointSourceID ▼", HTML("<ul><li>Identificador temporal da origem do ponto.</li>
                                                       <li>Vôos diferentes, por exemplo, tem PointSourceID diferentes.</li>")),
                   bsCollapsePanel("GPS Time ▼", HTML("<ul><li>Instante exato em que o pulso foi emitido.</li>
                                                  <li>Medido a partir do tempo base do sistema GPS Week Time.</li></ul>")),
                   bsCollapsePanel("RGB ▼", HTML("<ul><li>Valores das bandas Vermelho, Verde e Azul associadas ao ponto.</li></ul>")),
                   bsCollapsePanel("Compressão (.laz) ▼", HTML("<ul><li>Arquivo .las comprimido sem perda de dados.</li>
                                                               <li>Compatível com .lax.</li>
                                                               <li>Salvar/ler/comprimir/descomprimir exige processamento ligeiramente maior.</li></ul>")),
                   bsCollapsePanel("Indexação (.lax) ▼", HTML("<ul><li>Arquivo auxiliar que permite leitura rápida de regiões da nuvem de pontos.</li>
                                                              <li>Economiza processamento ao evitar a leitura do arquivo completo.</li>
                                                              <li>O arquivo .lax será criado na mesma pasta do arquivo selecionado.</li>")),
                   bsCollapsePanel("ID do formato LAS ▼", HTML("<ul><li>O arquivo .las tem 10 formatos de planilha (data frame) padronizados.</li>
                                                                <li>Formatos de 6 a 10 são mais novos e considerados aprimorados em relação à estruturação dos dados.</li>
                                                                <li>Resumo dos formatos:
                                                                <ul><li>0: X, Y, Z, intensidade, retorno, classificação.</li>
                                                                <li>1: + tempo GPS.</li>
                                                                <li>2: + RGB.</li>
                                                                <li>3: + tempo GPS + RGB.</li>
                                                                <li>4: + tempo GPS + waveform.</li>
                                                                <li>5: + tempo GPS + RGB + waveform.</li>
                                                                <li>6: Equivalente ao 1, mas LAS 1.4.</li>
                                                                <li>7: Equivalente ao 3, mas LAS 1.4.</li>
                                                                <li>8: Equivalente ao 5, mas LAS 1.4.</li>
                                                                <li>9: Como 6/7/8 mas com waveform.</li>
                                                                <li>10: Como 9 mas com RGB + NIR.</li>
                                                               </ul></li></ul>"))
        )
      ),
      
      #####################################
      #Aba Classificação de Ruídos Sidebar#
      #####################################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Classificação de Ruídos'",
        
        h4("Algoritmos"),
        radioButtons("algoritmo_ruidos", label = NULL,
                     choices = c("SOR" = "sor", "IVF" = "ivf"),
                     selected = "sor"),
        
        hr(),
        
        h4("Parâmetros"),
        uiOutput("parametros_ruidos"),
        
        actionButton("classificar_ruidos", "Classificar"),
        hr(),
        
        h4("Visualização"),
        checkboxInput("subamostrar", 
                      "Subamostrar pontos não ruído",
                      value = TRUE),
        br(),
        
        checkboxInput("mostrar_naoruidos", "Mostrar pontos não ruído", 
                      value = TRUE),
        
        conditionalPanel(condition = "input.subamostrar == true",
                         numericInput("ppmc", "Quantidade máxima de pontos por m³", value = 16, min = 1,
                                      max = 250, step = 1)),
        
        fluidRow(
          column(6,
                 selectInput("cor_ruidos", "Cor pontos ruído",
                             choices = c("Verde" = "green", "Azul" = "blue", 
                                         "Vermelho" = "red", "Amarelo" = "yellow"),
                             selected = "green")
          ),
          column(6,
                 selectInput("cor_nao_ruidos", "Cor pontos não ruído:",
                             choices = c("RGB" = "rgb", "Cinza" = "gray","Preto" = "black",
                                         "Azul" = "blue","Amarelo" = "yellow"),
                             selected = "rgb"))
        ),
        
        actionButton("visualizar_ruidos", "Visualizar"),
        hr(),
        
        h4("Classificação"),
        actionButton("aplicar_classificacao", "Salvar"),
        span(
          icon("info-circle"), 
          id = "ajuda_sal", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_sal", 
          title = "Salva a nuvem de pontos, conforme última classificação, no aplicativo. Agora você pode usá-la nas outras abas.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Pontos ruído"),
        actionButton("aplicar_classificacao_s_r", "Excluir"),
        span(
          icon("info-circle"), 
          id = "ajuda_exc", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_exc", 
          title = "Exclui os pontos classificados como ruído. Em seguida salva a nuvem de pontos no aplicativo.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Download"),
        checkboxInput("comprimir", "Comprimir (.laz)", value = TRUE),
        downloadButton("salvar_las_r", ""),
        hr(), 
        
        h4("Memória de renderização"),
        actionButton("limpar_memoria_r", "Limpar"),
        span(
          icon("info-circle"), 
          id = "ajuda_limp", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_limp", 
          title = "Exclui a nuvem de pontos da aba, mas não do aplicativo. Libera memória. Para visualizar novamente é necessário classificar.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Ajuda"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 24 'Classify points'"),
        bsCollapse(id = "explicacoes_algoritmos_ruidos", open = NULL,
                   
                   bsCollapsePanel("SOR (Statistical Outliers Removal) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
                        <li>Para cada ponto calcula a distância média de 'k' pontos vizinhos.</li>
                        <li>Qualquer ponto com distância média maior que o limite é classificado como ruído.</li>
                        <li>Se 'Quantílico' igual 'Não', então:
                        <ul><li>limite = distância média + ('m' * desvio padrão)</li></ul></li>
                        <li>Se 'Quantílico' igual 'Sim', então:
                        <ul><li>limite = quantile(distâncias, probs = 'm')</li>
                        <li>Nesse caso, 'm' representa o percentual de retenção, devendo estar entre 0 e 1 (ex.: 0.95 para manter 95% dos pontos mais densos).</li></ul></li>
                        </ul></span>")),
                   bsCollapsePanel("IVF (Isolated Voxels Filter) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
                        <li>O espaço 3D é dividido em voxels cúbicos com lado igual a 'res'.</li>
                        <li>Para cada ponto, é analisada uma vizinhança cúbica de 3×3×3 voxels, ou seja, o voxel central e seus 26 vizinhos imediatos.</li>
                        <li>O algoritmo conta a quantidade total de pontos presentes nesses 27 voxels.</li>
                        <li>Se a quantidade total de pontos (nos 27 voxels) for menor que 'n' então todos os pontos são considerados ruído (por estar em uma região muito isolada).</li>
                        </ul></span>")),
                   bsCollapsePanel("Subamostragem ▼", HTML("<span style='font-size:smaller;'><ul>
                        <li>A nuvem de pontos é voxelizada em uma grade cúbica com lado igual a 1.</li>
                        <li>Para cada voxel, calcula-se o centróide (média das coordenadas dos pontos contidos nele).</li>
                        <li>São mantidos como representantes do voxel a quantidade máxima de pontos definida por m³.</li>
                        <li>Apenas pontos não ruídos serão subamostrados.</li></ul>"
                   )))
      ),
      
      ###################################
      #Aba Classificaçao do chao Sidebar#     
      ###################################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'Classificação do Chão'",
        
        h4("Algoritmos"),
        radioButtons("algoritmo_solo", label = NULL,
                     choices = c("CSF" = "csf", "PMF" = "pmf", "MCC" = "mcc"),
                     selected = "csf"),
        
        h4("Parâmetros"),
        uiOutput("parametros_algo"),
        
        actionButton("classificar_chao", "Classificar"),
        hr(),
        
        h4("Visualização"),
        checkboxInput("subamostrar_chao", 
                      "Subamostrar pontos não chão",
                      value = TRUE),
        br(),
        checkboxInput("mostrar_outros", "Mostrar pontos não chão", value = TRUE),
        
        conditionalPanel(condition = "input.subamostrar_chao == true",
                         numericInput("ppmc_c", "Quantidade máxima de pontos por m³",
                                      value = 16, min = 1, max = 250, step = 1)),
        
        fluidRow(
          column(6,
                 selectInput("cor_chao", "Cor pontos chão:",
                             choices = c("Verde" = "green", "Azul" = "blue", 
                                         "Vermelho" = "red", "Amarelo" = "yellow"),
                             selected = "green")
          ),
          column(6,
                 selectInput("cor_nao_chao", "Cor pontos não chão:",
                             choices = c("RGB" = "rgb",
                                         "Cinza" = "gray","Preto" = "black",
                                         "Azul" = "blue","Amarelo" = "yellow"),
                             selected = "rgb"))
        ),
        
        actionButton("visualizar_solo", "Visualizar"),
        hr(),
        
        h4("Classificação"),
        actionButton("aplicar_classificacao", "Salvar"),
        hr(),
        
        h4("Download"),
        checkboxInput("comprimir", "Comprimir (.laz)", value = TRUE),
        downloadButton("salvar_las_c", "Completo"),
        span(
          icon("info-circle"), 
          id = "ajuda_dc", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_dc", 
          title = "Baixa a nuvem de pontos com todos os pontos.",
          placement = "right", 
          trigger = "hover"
        ),
        br(), br(),
        downloadButton("salvar_las_cpc", "Apenas pontos-chão"),
        span(
          icon("info-circle"), 
          id = "ajuda_cpc", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_cpc", 
          title = "Baixa a nuvem de pontos apenas com os pontos classificados como chão.",
          placement = "right", 
          trigger = "hover"
        ),
        br(), br(),
        downloadButton("salvar_las_cv", "Sem pontos-chão"),
        span(
          icon("info-circle"), 
          id = "ajuda_spc", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_spc", 
          title = "Baixa a nuvem de pontos com todos os pontos excluindo os classificados como chão.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Memória de renderização"),
        actionButton("limpar_memoria_c", "Limpar"),
        hr(),
        
        h4("Ajuda"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 24 'Classify points'"),
        bsCollapse(id = "explicacoes_algoritmos", open = NULL,
                   
                   bsCollapsePanel("CSF (Cloth Simulation Filter) ▼", HTML("<span style='font-size:smaller;'><ul>
    <li>Inverte a nuvem de pontos (Cabeça pra baixo) e simula um 'pano' caindo sobre o terreno, que se ajusta aos pontos e ajuda a identificar o solo.</li>
    <li>Os pontos são classificados de acordo com sua distância vertical ao pano simulado.</li>
    <li>Adequado para terrenos irregulares e vegetação densa.</li>
    <li><strong>Parâmetros</strong>:
    <ul><li><em>Encosta íngreme (sloop_smoth)</em>: Aplica correção para terrenos íngremes.</li>
    <li><em>Limite distância vertical (class_threshold)</em>: Racional positivo. Limite da distância vertical entre um ponto e o 'pano' para ser classificado como chão.</li>
    <li><em>Resolução 'pano' (cloth_resolution)</em>: Racional positivo. Distância horizontal entre os nós da malha (grade) do 'pano'.</li>
    <li><em>Rigidez (rigidness)</em>: Controla a rigidez com que o 'pano' dobra. Quanto mais flexível mais o nó da grade se deslocará verticalmente até o próximo ponto. (Lembre-se: O 'pano' está caindo)
      <ul><li>Flexível (maior adaptação)</li>
          <li>Médio</li>
          <li>Rígido (menor adaptação)</li></ul></li>
    <li><em>Iterações (iterations)</em>: Inteiro positivo. Valor padrão. Máximo de iterações na simulação da queda do 'pano'.</li>
    <li><em>Distância passo (time_step)</em>: Racional positivo. Valor padronizado. Passo do deslocamento vertical descendente (queda).</li></ul> 
  </ul>
  <p><a href='https://www.mdpi.com/2072-4292/8/6/501' target='_blank'>Zhang et al., 2016</a></p>
  </span>")),
                   
                   bsCollapsePanel("PMF (Progressive Morphological Filter) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
    <li>Aplica operações morfológicas de abertura de forma progressiva sobre a nuvem de pontos, com o objetivo de remover vegetação e preservar os pontos de solo.</li>
    <li>Ou seja, cria-se uma janela que cresce linear ou exponencialmente, suaviza a superfície e
        calcula a diferença entre o ponto original e a superfície estimada.</li>
    <li>Se a distância entre o ponto original e a superfície é menor que o limite definido, então é classificado como chão.</li>
    <li>É adequado para áreas planas e topografia simples.</li>
    <li>É sensível à escolha do tamanho da janela e a distância aceitável entre ponto e superfície.</li>
    <li><strong>Parâmetros</strong>:
    <ul><li><em>Tamanho janela (ws)</em>: Racional positivo. Lista. Tamanho das janelas aplicadas progressivamente.</li>
    <li><em>Limite (th)</em>: Racional positivo. Lista (de comprimento igual ao ws). Distâncias máximas entre superfície estimada e ponto.</li></ul>
    <li>Os parâmetros podem ser calculados pela função 'util_makeZhangParam' disponível no pacote lidR.</ul>
    <p><a href='https://www.researchgate.net/publication/3203162_A_progressive_morphological_filter_for_removing_nonground_measurements_from_airborne_LIDAR_data' 
      target='_blank'>Zhang et al., 2003</a></p><span>")),
                   
                   bsCollapsePanel("MCC (Multiscale Curvature Classification) ▼", 
                                   HTML("<span style='font-size:smaller;'<ul>
    <li>Utiliza a curvatura local da superfície em múltiplas escalas para distinguir pontos de solo e vegetação.</li>
    <li>Avalia o formato da superfície ao redor de cada ponto em diferentes tamanhos de vizinhança, identificando áreas suaves (solo) e abruptas (vegetação).</li>
    <li>Funciona bem em áreas com relevo acidentado.</li>
    <li>Opção quando CSF e PMF não funcionam bem, mas é mais lento por envolver análise multiescala.</li>
    <li><strong>Parâmetros</strong>:
    <ul><li><em>Tamanho da janela (s)</em>: Racional positivo. Define o tamanho da janela que avalia a curvatura. Nuvens mais densas requerem valores menores, e nuvens mais esparsas, valores maiores.</li>
    <li><em>Limite de curvatura (t)</em>: Racional positivo. Valor máximo de curvatura para ser considerado chão.</li></ul>
  </ul>
    <p><a href='https://www.researchgate.net/publication/3204849_A_Multiscale_Curvature_Algorithm_for_Classifying_Discrete_Return_LiDAR_in_Forested_Environments'
      target='_blank'>Evans, Jeffrey S.; Hudak, Andrew T. 2007.</a></p></span>")),
                   bsCollapsePanel("Subamostragem ▼", HTML("<span style='font-size:smaller;'><ul>
                        <li>A nuvem de pontos é voxelizada em uma grade cúbica com lado igual a 1.</li>
                        <li>Para cada voxel, calcula-se o centróide (média das coordenadas dos pontos contidos nele).</li>
                        <li>São mantidos como representantes do voxel a quantidade máxima de pontos definida por m³.</li>
                        <li>Apenas pontos não chão serão subamostrados.</li></ul>"
                   )))
        
      ),
      
      #################
      #Aba MDT Sidebar#      
      #################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'MDT'",
        
        h4("Algoritmos MDT"),
        radioButtons("algoritmo_mdt", label = NULL,
                     choices = c("KNN-IDW" = "idw","TIN" = "tin", "Krigagem" = "krig"),
                     selected = "idw"),
        
        h4("Parâmetros"),
        uiOutput("parametros_mdt"),
        
        actionButton("gerar_mdt", "Gerar"),
        hr(),
        
        h4("Download"),
        downloadButton("baixar_mdt", "MDT"),
        span(
          icon("info-circle"), 
          id = "ajuda_mdt", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_mdt", 
          title = "Baixa o MDT gerado como arquivo raster de formato TIF.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Memória de renderização"),
        actionButton("limpar_memoria_s", "Limpar"),
        hr(),
        
        h4("Ajuda"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 34 'dtm_*'"),
        bsCollapse(id = "explicacoes_algoritmos_norm", open = NULL,
                   bsCollapsePanel("Modelo Digital do Terreno (MDT) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Representação matemática e digital da superfície do solo, ou seja, exclui-se objetos sobre o mesmo.</li>
        <li>Raster onde cada célula contém a altitude do terreno naquele ponto.</li>
        <li>A resolução da malha (grid) corresponde ao tamanho do lado do pixel, determinando o nível de detalhe do modelo.</li>
        <li>É gerado a partir de pontos classificados como chão (classe 2)</li>
                          </ul></span>")),
                   bsCollapsePanel("KNN-IDW (Inverse Distance Weighting) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Este algoritmo é composto por dois modelos: KNN e IDW, aplicados na interpolação do Modelo Digital de Terreno (MDT) a partir dos pontos classificados como chão.</li>
        <li>KNN = K-Nearest Neighbour = Identifica, para cada ponto do terreno a ser interpolado, os k pontos de solo mais próximos.</li>
        <li>IDW = Inverse Distance Weighting = Calcula o valor de altitude para cada píxel com base na média ponderada inversa da distância aos k vizinhos identificados. Pontos mais próximos recebem maior peso na estimativa.</li>
        <li>No fim cada célula do raster do MDT receberá um valor de altitude que representa a superfície contínua e suavizada do terreno.</li>
        <li><strong>Parâmetros</strong>:</li>
        <ul><li><em>k</em>: Inteiro positivo. Quantidade de pontos vizinhos.</li>
        <li><em>p</em>: Racional positivo. Expoente da ponderação da distância inversa (define o peso dos vizinhos próximos).</li>
        <li><em>rmax</em>: Racional positivo. Raio máximo de busca para encontrar os 'k' vizinhos.</li></ul>
                          </ul></span>")),
                   bsCollapsePanel("TIN (Triangulated Irregular Network) ▼",
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Constrói uma triangulação de Delaunay sobre os pontos classificados como chão e estima a altitude dentro de cada triângulo por interpolação linear.</li>
        <li>Triangulação de Delaunay = Cada ponto torna-se um vértice, assim a triangulação garante que o círculo circunscrito a cada triângulo não contenha outros pontos.</li>
        <li>Interpolação linear = Método matemático que estima uma valor desconhecido entre dois pontos conectado-os com uma linha reta.</li>
        <li>A limitação deste algoritmo se encontra nas bordas da nuvem de pontos, onde podem sobrar pontos que não fecham triângulos. Quando isso acontece é possível usar o parâmetro
        'Extrapolação' que usa o algoritmo IDW para preencher o que resta.</li>
        <li>Não há parâmetros para esse algoritmo.</li>
                        </ul></span>")),
                   bsCollapsePanel("Krigagem ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Método avançado de interpolação geoestatística, baseado na dependência espacial entre os valores amostrados.</li>
        <li>Krigagem = Estima valores desconhecidos a partir da correlação espacial dos dados, modelada por meio de um variograma.</li>
        <li>Universal = Assume que a média não é constante na área mas que varia segundo uma tendência espacial (por exemplo, uma inclinação geral do terreno).</li>
        <li>O variograma descreve como a semelhança entre pontos diminui à medida que aumenta a distância entre eles, permitindo ponderar as contribuições de cada ponto vizinho.</li>
        <li>Em conjunto com o variograma utiliza-se a abordagem KNN (já explicada em IDW) que definirá o subconjunto de pontos usados na estimativa.</li>
        <li>Neste aplicativo não será possível ajustar o variograma. Sendo assim o algoritmo realizará uma predição por mínimos quadrados ordinários ou ponderados, o que não considera explicitamente a estrutura espacial dos dados.</li>
                       </ul></span>"))
        )
      ),
      
      ############################
      #Aba Normalização MDS / CHM#      
      ############################
      
      conditionalPanel(
        condition = "input.aba_ativa == 'MDS, Normalização e CHM'",
        
        h4("Algoritmos MDS / CHM"),
        radioButtons("algoritmo_mds", label = NULL,
                     choices = c("P2R" = "p2r", "TIN" = "tin", "Pit-free" = "pf"),
                     selected = "p2r"),
        
        h4("Parâmetros"),
        uiOutput("parametros_mds"),
        
        actionButton("gerar_mds", "Gerar MDS / CHM"),
        span(
          icon("info-circle"), 
          id = "ajuda_mdschm", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_mdschm", 
          title = "MDS é gerado a partir de uma nuvem de pontos salva não normalizada. CHM é gerado a partir de uma nuvem de pontos salva normalizada.",
          placement = "right", 
          trigger = "hover"
        ),
        
        hr(),
        
        h4("Normalização"),
        actionButton("aplicar_normalizacao", "Aplicar"),
        span(
          icon("info-circle"), 
          id = "ajuda_apl", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_apl", 
          title = "Normaliza a altura da nuvem de pontos. Utiliza o último MDT gerado.",
          placement = "right", 
          trigger = "hover"
        ),
        
        br(),
        br(),
        
        actionButton("salvar_norm", "Salvar"),
        span(
          icon("info-circle"), 
          id = "ajuda_salv", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_salv", 
          title = "Salva a nuvem de pontos normalizada no aplicativo. Agora você pode gerar um CHM.",
          placement = "right", 
          trigger = "hover"
        ),
        
        hr(),
        
        h4("Download"),
        downloadButton("baixar_mds", "MDS / CHM"),
        span(
          icon("info-circle"), 
          id = "ajuda_mds", 
          style = "color: #b5b5b5; cursor: help; margin-left: 5px; font-size: 0.9em; vertical-align: middle;"
        ),
        bsTooltip(
          id = "ajuda_mds", 
          title = "Baixa o MDS ou CHM gerado como arquivo raster de formato TIF.",
          placement = "right", 
          trigger = "hover"
        ),
        hr(),
        
        h4("Download"),
        checkboxInput("comprimir", "Comprimir (.laz)", value = TRUE),
        downloadButton("salvar_las_n", "Nuvem de Pontos"),
        hr(),
        
        h4("Memória de renderização"),
        actionButton("limpar_memoria_mds", "Limpar"),
        hr(),
        
        h4("Ajuda"),
        tags$a(href = "https://cran.r-project.org/web/packages/lidR/lidR.pdf", 
               target = "_blank", "CRAN lidR pag. 31'dsm_*'"),
        bsCollapse(id = "explicacoes_algoritmos_mds", open = NULL,
                   bsCollapsePanel("Modelo Digital do Terreno (MDS) ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
                   <li>Representação matemática e digital da superfície do terreno, incluindo todos os objetos sobre ele, como vegetação, edificações e outras estruturas.</li>
                   <li>Raster onde cada célula contém a altitude da superfície naquele ponto</li>
                   <li>Resolução da malha (grid) = medida do lado do pixel.</li>
                   <li>Utiliza os primeiros retornos (ReturnNumber) ou pontos mais altos em cada píxel.</li>
                   <li>Gerado a partir de uma nuvem de pontos não normalizada.</li>
                        </ul></span>")),
                   bsCollapsePanel("Normalização ▼", 
                                   HTML("<span style='font-size:smaller;'><ul>
        <li>Geralmente a altura ('Z') dos pontos são calculados em altitude acima do nível médio do mar.</li>
        <li>O processo de normalização converte essas alturas para valores relativos ao terreno, removendo a influência do relevo.</li>
        <li>Z<i>normalizado</i> = Z<i>original</i> - Z<i>terreno</i></li>
        <ul><li>Z<i>terreno</i> provém do último MDT gerado.</li></ul>
        <li>Assim, cada ponto passa a representar sua altura real acima do solo, facilitando o cálculo de métricas estruturais, como altura da vegetação, densidade e volume.</li>
        <li>Pontos degenerados são caracterizados como pontos que ocupam o mesmo XY, mas com diferentes Z.
        Isso pode gerar consequências para processamentos em geral. 
        Por isso, quando identificados, o programa usa os pontos com menor Z.</li>
                                  </ul></span>")),
                   bsCollapsePanel("Modelo Digital de Altura do Dossel (CHM) ▼",
                                   HTML("<span style='font-size:smaller;'><ul>
                    <li>Representação matemática e digital do dossel da floresta.</li>
                    <li>Raster onde cada célula contém a altura da copa das árvores.</li>
                    <li>Basicamente é parecido a um MDS, só que gerado a partir de uma nuvem de pontos normalizada.</li>")),
                   bsCollapsePanel("P2R (Point to Raster) ▼",
                                   HTML("<span style='font-size:smaller;'><ul>
                                   <li>Rasteriza a nuvem de pontos e atribui a cada célula o ponto de maior altura (Z) encontrado dentro dela.</li>
                                   <li>Processamento mais leve.</li>
                                   <li>Suscetível a 'buracos': depressões no modelo digital devido às células vazias (sem pontos) do raster.</li>
                                   <li><strong>Parâmetros</strong>:
                                   <ul><li><em>Raio do círculo</em>: Racional positivo. Raio de um círculo que replica o ponto original em até 8 direções horizontais, aumentando a área de influência do ponto e reduzindo lacunas.</li>
                                   <li><em>Função de Interpolação</em>: Função. Interpola células vazias do raster. Disponíveis:
                                    <ul><li>tin()</li>
                                    <li>knnidw()</li>
                                    <li>kriging()</li></ul></li></ul></li></span>")),
                   bsCollapsePanel("TIN (Triangulated Irregular Network) ▼",
                                   HTML("<span style='font-size:smaller;'><ul>
                                        <li>Constrói uma triangulação de Delaunay a partir dos pontos da nuvem e interpola os valores dentro dos triângulos para gerar o raster da superfície.</li>
                                        <li>Processamento mais leve.</li>
                                        <li>Apropriado para nuvens de pontos densas.</li>
                                        <li><strong>Parâmetros</strong>:
                                        <ul><li><em>Máximo lado do triângulo</em>: Racional positivo. Comprimento máximo permitido das arestas dos triângulos. Controla a qualidade da triangulação, evitando geometrias muito alongadas e possíveis artefatos.</li>
                                        <li><em>Pontos mais altos por píxel</em>: Lógico. Se selecionado utiliza apenas os pontos mais altos por píxel, diminuindo processamento. Se não selecionado então usa todos os primeiros retornos (ReturnNumber).</li>
                                        </ul></li></ul></span>")),
                   bsCollapsePanel("Pit-free ▼",
                                   HTML("<span style='font-size:smaller;'><ul>
                        <li>Desenvolvido para áreas com copas complexas, diminuindo os 'buracos' que aparecem no raster devido à ausência de pontos</li>
                                        <li>Constrói múltiplas triangulações de Delaunay em diferentes níveis de corte vertical e, em seguida, combina as superfícies resultantes para gerar um modelo contínuo e realista da superfície do dossel.</li>
                                        <li>Processamento mais pesado.</li>
                                        <li><strong>Parâmetros</strong>:
                                        <ul><li><em>Limiares de corte vertical</em>: Racional positivo. Lista. Níveis de altura para triangulação.</li>
                                        <li><em>Máximo lado do triângulo</em>: Racional positivo. Comprimento máximo permitido das arestas dos triângulos. Controla a qualidade da triangulação, evitando geometrias muito alongadas e possíveis artefatos.</li>
                                        <li><em>Raio do círculo</em>: Racional positivo. Raio de um círculo que replica o ponto original em até 8 direções horizontais, aumentando a área de influência do ponto e reduzindo lacunas.</li>
                                        <li><em>Ponto mais alto por píxel</em>: Lógico. Se selecionado utiliza apenas os pontos mais altos por píxel, diminuindo processamento. Se não selecionado então usa todos os primeiros retornos (ReturnNumber).</li>
                                        </ul></li></ul>
                                        <p><a href='https://ris.utwente.nl/ws/portalfiles/portal/453105235/s3.pdf' target='_blank'>Khosravipour et al. 2014</a></p></span>"))
        )
      )),
    
    mainPanel(
      tabsetPanel(id = "aba_ativa",
                  
                  #####################
                  #Aba Início Mainpanel                  
                  #####################
                  
                  tabPanel("Início",
                           fluidRow(
                             column(12, 
                                    div(style = "text-align: center; padding: 20px;",
                                        h2("Painel Principal"),
                                        h6("Aqui você visualizará, em 3D e com controle de órbita da câmera, o resultado dos processamentos e caixas de texto com as métricas das análises.")
                                    )
                             )
                           ),
                           
                           hr(),
                           
                           fluidRow(
                             column(12, 
                                    div(style = "text-align: center; padding: 30px; background-color: #f8f9fa; border-radius: 10px;",
                                        h1("ProcessaLAS", style = "color: #2c3e50; font-weight: bold; margin-bottom: 0px;"),
                                        p("Análise e processamento inicial de nuvens de pontos LiDAR.", style = "font-size: 18px; color: #7f8c8d;"),
                                        p("Para acessar o manual e/ou a versão mais atual, acesse:", style = "font-size: 12px; color: #7f8c8d;"),
                                        a(href = "https://github.com/Pedro-ASC/R-WebApp-Shiny-ProcessaLAS", 
                                          target = "_blank", 
                                          class = "btn btn-default",
                                          style = "margin-bottom: 20px; color: #2c3e50; border-color: #bdc3c7;",
                                          icon("github"), " GitHub"),
                                        
                                        br(),
                                        p("Fluxo de trabalho proposto:", style = "font-size: 15px; color: #7f8c8d;")
                                    )
                             )
                           ),
                           
                           br(),
                           
                           fluidRow(
                             column(8, offset = 2,
                                    
                                    # Passo 1: Diagnóstico
                                    div(style = "border-left: 4px solid #3498db; padding-left: 20px; margin-bottom: 30px; position: relative;",
                                        h4(icon("search"), "1. Análise"),
                                        p("Extração de métricas de densidade e atributos.")
                                    ),
                                    
                                    # Passo 2: Classificação
                                    div(style = "border-left: 4px solid #f1c40f; padding-left: 20px; margin-bottom: 30px;",
                                        h4(icon("tags"), "2. Classificação"),
                                        p("Identificação de pontos ruído (Classe 18) e chão (Classe 2).")
                                    ),
                                    
                                    #2.1 e 2.2
                                    fluidRow(
                                      column(6, 
                                             div(style = "background: #fff3e0; padding: 15px; border-radius: 5px; border-top: 4px solid #f39c12; text-align: center; min-height: 140px; box-shadow: 2px 2px 5px rgba(0,0,0,0.05);",
                                                 h5(tags$b("Classificação de pontos ruído")),
                                                 p("Pontos que não representam a superfície alvo de sensoriamento.", style = "color: #5d4037;"),
                                                 p(em("Algoritmos:"), style = "color: #5d4037;"),
                                                 p("- SOR", style = "color: #5d4037;"),
                                                 p("- IVF", style = "color: #5d4037;")
                                             )
                                      ),
                                      column(6,
                                             div(style = "background: #fff3e0; padding: 15px; border-radius: 5px; border-top: 4px solid #f39c12; text-align: center; min-height: 140px; box-shadow: 2px 2px 5px rgba(0,0,0,0.05);",
                                                 h5(tags$b("Classificação de pontos chão")),
                                                 p("Pontos que representam a superfície do terreno.", style = "color: #5d4037;"),
                                                 p(em("Algoritmos:"), style = "color: #5d4037;"),
                                                 p("- CSF", style = "color: #5d4037;"),
                                                 p("- PMF", style = "color: #5d4037;"),
                                                 p("- MCC", style = "color: #5d4037;")
                                             )
                                      )
                                    ),
                                    
                                    br(),
                                    
                                    #3 Geração de Modelos Digitais
                                    div(style = "border-left: 4px solid #795548; padding-left: 20px; margin-bottom: 30px;",
                                        h4(icon("layer-group"), "3. Modelos Digitais"),
                                        p("Geração de Modelos Digitais de Terreno (MDT) e de Superfície (MDS).")
                                    ),
                                    
                                    #3.1 e 3.2
                                    fluidRow(
                                      column(6, 
                                             div(style = "background: #efebe9; padding: 15px; border-radius: 5px; border-top: 4px solid #795548; text-align: center; min-height: 140px; box-shadow: 2px 2px 5px rgba(0,0,0,0.05);",
                                                 h5(tags$b("MDT")),
                                                 p("Raster que representa as feições do terreno. Obrigatório pontos chão classificados.", style = "color: #5d4037;"),
                                                 p(em("Algoritmos:"), style = "color: #5d4037;"),
                                                 p("- KNN-IDW", style = "color: #5d4037;"),
                                                 p("- TIN", style = "color: #5d4037;"),
                                                 p("- Krigagem", style = "color: #5d4037;")
                                             )
                                      ),
                                      column(6,
                                             div(style = "background: #efebe9; padding: 15px; border-radius: 5px; border-top: 4px solid #795548; text-align: center; min-height: 140px; box-shadow: 2px 2px 5px rgba(0,0,0,0.05);",
                                                 h5(tags$b("MDS")),
                                                 p("Raster que representa as feições do terreno, incluso o objetos sob ele.", style = "color: #5d4037;"),
                                                 p(em("Algoritmos:"), style = "color: #5d4037;"),
                                                 p("- P2R", style = "color: #5d4037;"),
                                                 p("- TIN", style = "color: #5d4037;"),
                                                 p("- Pit-free", style = "color: #5d4037;")
                                             )
                                      )
                                    ),
                                    
                                    # Passo 4: Normalização
                                    div(style = "border-left: 4px solid #9b59b6; padding-left: 20px; margin-bottom: 30px;",
                                        h4(icon("mountain"), "4. Normalização"),
                                        p("Processo de transformação dos valores de altitude em altura absoluta através da subtração da altura dos pontos pela altura do MDT.")
                                    ),
                                    
                                    # Passo 5: Modelo Digital de Altura do Dossel (CHM)
                                    div(style = "border-left: 4px solid #27ae60; padding-left: 20px; margin-bottom: 30px;",
                                        h4(icon("tree"), "5. Modelo Digital de Altura do Dossel (CHM)"),
                                        p("Raster que representa as feições da copa das árvores, com suas respectivas alturas absolutas. Pode ser entendida como a subtração de MDS por MDT.")
                                    )
                             )
                           )
                  ), 
                  
                  ##########################
                  #Aba Diagnostico Mainpanel                  
                  ##########################
                  
                  tabPanel("Análise",
                           uiOutput("main_info")),
                  
                  ##################################
                  #Aba Classificaçao Ruido Mainpanel
                  ##################################
                  
                  tabPanel("Classificação de Ruídos",
                           div(class = "plot-border", 
                               withSpinner(rglwidgetOutput("plot_ruidos",
                                                           width = "100%", height = "600px"), 
                                           type = 6, color = "green")),
                           br(),
                           h4("Análise dos pontos ruído"),
                           uiOutput("diag_ruidos")
                  ),
                  
                  #################################
                  #Aba Classificacao Chão Mainpanel
                  #################################
                  
                  tabPanel("Classificação do Chão",
                           div(class = "plot-border", 
                               withSpinner(rglwidgetOutput("plot_mdt", 
                                                           width = "100%", height = "600px"), 
                                           type = 6, color = "green")),
                           br(),
                           h4("Análise dos pontos chão"),
                           uiOutput("diag_solo_classificado")
                  ),
                  
                  ###################
                  #Aba MDT Mainpanel#
                  ###################
                  
                  tabPanel("MDT",
                           div(class = "plot-border",
                               withSpinner(rglwidgetOutput("plot_mdtn", 
                                                           width = "100%", height = "600px"), 
                                           type = 6, color = "green")),
                           br(),
                           h4("Análise MDT"),
                           uiOutput("diag_mdt")
                  ),
                  
                  #########
                  #Aba MDS#
                  #########
                  
                  tabPanel("MDS, Normalização e CHM",
                           div(class = "plot-border",
                               withSpinner(rglwidgetOutput("plot_mds", 
                                                           width = "100%", height = "600px"), 
                                           type = 6, color = "green")),
                           br(),
                           h4("Análise MDS / CHM"),
                           uiOutput("diag_mds"),
                           br(),
                           h4("Análise Normalização"),
                           uiOutput("diag_norm")
                  )
      )
    )
  )
)

#########
#Servidor
#########

server <- function(input, output, session) {
  lasData <- reactiveVal(NULL)
  lasSoloClassificado <- reactiveVal(NULL)
  lasRuidos <- reactiveVal(NULL)
  mdt <- reactiveVal(NULL)
  mds <- reactiveVal(NULL)
  lasNormalizado <- reactiveVal(NULL)
  totalpp <- reactiveVal(NULL)
  hdr <- reactiveVal(NULL)
  diag_corr <- reactiveVal("hdr")
  totalppc <- reactiveVal(NULL)
  show_na <- reactiveVal(NULL)
  
  ################
  #Aba Análise
  ################
  
  #Input  
  observeEvent(input$lasfile, {
    req(input$lasfile)
    
    if (!is.null(lasData())) {
      lasData(NULL)
      lasSoloClassificado(NULL)
      mds(NULL)
      mdt(NULL)
      lasRuidos(NULL)
      hdr(NULL)
      lasNormalizado(NULL)
      totalpp(NULL)
      totalppc(NULL)
      show_na(NULL)
      
      output$plot_mds <- NULL
      output$plot_mdtn <- NULL
      output$diag_mdt <- NULL
      output$diag_mds <- NULL
      output$diag_norm <- NULL
      output$plot_mdt <- NULL
      output$diag_solo_classificado <- NULL
      output$plot_ruidos <- NULL
      output$diag_ruidos <- NULL
      output$diag_info <- NULL
    }
    
    las <- readLAS(input$lasfile$datapath)
    if (is.empty(las)) {
      showNotification("Arquivo LAS vazio ou inválido.", type = "error")
      return()
    }
    
    lasData(las)
    hdr(readLASheader(input$lasfile$datapath))
    diag_corr("hdr")
    output$diag_info <- NULL
  })
  
  output$arquivo_status <- renderPrint({
    if (!is.null(lasData())) {
      cat("Arquivo carregado com sucesso.")
    } else {
      cat("Nenhum arquivo carregado.")
    }
  })
  
  observeEvent(input$limpar_classificacao, {
    req(lasData())
    las <- lasData()
    las$Classification <- as.integer(0)
    lasData(las)
    
    showNotification("Classificação limpa!",
                     type = "message")
  })
  
  output$salvar_las_d <- downloadHandler(
    filename = function() {
      if (input$comprimir) {
        paste0("arquivo_", Sys.Date(), ".laz")
      } else {
        paste0("arquivo_", Sys.Date(), ".las")
      }
    },
    content = function(file) {
      req(lasData())
      las <- lasData()
      writeLAS(las, file)
    }
  )
  
  observeEvent(input$gerar_lax, {
    req(input$arquivo_las)
    caminho_las <- input$arquivo_las$datapath
    
    rlas::writelax(caminho_las)
    
    showNotification("Índice .lax criado com sucesso!", type = "message")
  })
  
  output$hdr_info <- renderPrint({
    req(hdr())
    
    withProgress(message = "Carregando metadados...", value = 0, {
      hdr <- hdr()
      
      dia <- hdr$`File Creation Day of Year`
      ano <- hdr$`File Creation Year`
      data <- as.Date(dia - 1, origin = paste0(ano, "-01-01"))
      dataf <- format(data, "%d/%m/%Y")
      
      cat("### Resumo Metadados ### \n")
      cat("Data de criação:", dataf, "\n")
      cat("ID do formato LAS:", hdr$`Point Data Format ID`, "\n")
      cat("Total de pontos:", hdr$`Number of point records`, "\n")
      cat("Quantidade de pontos por retorno:", hdr$`Number of points by return`, "\n")
      cat("Max e Min X:", hdr$`Max X`, hdr$`Min X`, "\n")
      cat("Max e Min Y:", hdr$`Max Y`, hdr$`Min Y`, "\n")
      cat("Max e Min Z:", hdr$`Max Z`, hdr$`Min Z`, "\n")
    })
  })
  
  observeEvent(input$gerar_diag, {
    output$diag_info <- renderPrint({
      req(lasData())
      
      withProgress(message = "Carregando Análise...", value = 0, {
        
        las <- lasData()
        header <- las@header
        ladox <- (header@PHB$`Max X` - header@PHB$`Min X`)
        ladoy <- (header@PHB$`Max Y` - header@PHB$`Min Y`)
        area_bbox <- ladox * ladoy
        alt_bbox <- (header@PHB$`Max Z` - header@PHB$`Min Z`)
        vol_bbox <- area_bbox * alt_bbox
        xscale <- header@PHB$`X scale factor`
        yscale <- header@PHB$`Y scale factor`
        zscale <- header@PHB$`Z scale factor`
        xoffset <- header@PHB$`X offset`
        yoffset <- header@PHB$`Y offset`
        zoffset <- header@PHB$`Z offset`
        
        las_pr <- filter_first(las)
        ppg <- rasterize_density(las, res = 1)
        ppg_pr <- rasterize_density(las_pr, res = 1)
        v_contagem <- values(ppg)
        n_cel_p <- sum(v_contagem > 0, na.rm = TRUE)
        v_contagem_pr <- values(ppg_pr)
        n_cel_pr <- sum(v_contagem_pr > 0, na.rm = TRUE)
        ppd <- npoints(las_pr) / n_cel_pr
        sps <- 1 / sqrt(ppd)
        
        voxels <- voxel_metrics(las, ~length(Z), voxel_size = 1, all_voxels = FALSE)
        nvoxels <- nrow(voxels)
        med_pvox <- round(mean(voxels$V1, na.rm = TRUE), 0)
        median_pvox <- round(median(voxels$V1, na.rm = TRUE), 0)
        sd_pvox <- round(sd(voxels$V1, na.rm = TRUE), 0)
        
        # Verifica agrupamento dos pontos de solo por desvio padrão da densidade
        solo <- filter_poi(las, Classification == 2)
        if (npoints(solo) > 0) {
          dens_grid <- grid_density(solo, res = 1)
          dens_sd <- sd(values(dens_grid), na.rm = TRUE)
        } else {
          dens_sd <- NA
        }
        
        # Verificação de normalização com base na mediana de Z do solo
        if (npoints(solo) > 0) {
          mediana_z_solo <- median(solo@data$Z, na.rm = TRUE)
          esta_normalizada <- abs(mediana_z_solo) <= 0.5
        } else {
          mediana_z_solo <- NA
          esta_normalizada <- NA
        }
        
        cat("### XYZ ### \n")
        
        # Análise CRS
        crs_info <- sf::st_crs(las)
        if (!is.na(crs_info$epsg)) {
          cat("Sistema de Coordenadas:", crs_info$epsg, "-", crs_info$Name, "\n")
        } else {
          cat("Sistema de Coordenadas:", crs_info$proj4string, "\n")
        }
        
        # Verificação da escala das coordenadas
        med_x <- mean(las@data$X, na.rm = TRUE)
        if (abs(med_x) < 166000) {
          cat("Média da coordenada X < 166 mil: Sistema local ou reduzido.\n")
        }
        
        # Análise sobre Intensity
        tem_intensity <- "Intensity" %in% names(las@data) &&
          mean(!is.na(las@data$Intensity) & las@data$Intensity > 0, na.rm = TRUE) > 0.95
        
        # Análise sobre retornos
        tem_return_number <- "ReturnNumber" %in% names(las@data) &&
          mean(!is.na(las@data$ReturnNumber) & las@data$ReturnNumber > 0) > 0.95
        tem_number_of_returns <- "NumberOfReturns" %in% names(las@data) &&
          mean(!is.na(las@data$NumberOfReturns) & las@data$NumberOfReturns > 0) > 0.95
        
        # Análise sobre RGB
        tem_rgb_valido <- all(c("R", "G", "B") %in% names(las@data)) &&
          mean(rowSums(las@data[, c("R", "G", "B")]) > 0, na.rm = TRUE) > 0.95
        
        simulado_rgb <- FALSE
        if (tem_rgb_valido) {
          rgb_vals <- las@data[, c("R", "G", "B")]
          geom_vars <- las@data[, c("X", "Y", "Z")]
          cors <- cor(cbind(geom_vars, rgb_vals), use = "complete.obs")
          cor_geom_rgb <- cors[c("X", "Y", "Z"), c("R", "G", "B")]
          simulado_rgb <- any(abs(cor_geom_rgb) > 0.85)
        }
        
        # Verificação de classificação
        if ("Classification" %in% names(las@data)) {
          classes_presentes <- unique(na.omit(las@data$Classification))
          esta_classificada <- length(classes_presentes) > 1
          tem_chao_classificado <- 2 %in% classes_presentes
        } else {
          esta_classificada <- FALSE
          tem_chao_classificado <- FALSE
        }
        
        cat("Total de pontos:", npoints(las), "\n")
        cat("Lado X bbox (m):", round(ladox, 2), "\n")
        cat("Lado Y bbox (m):", round(ladoy, 2), "\n")
        cat("Área bbox (m²):", round(area_bbox, 2), "\n")
        cat("Área ocupada por pontos (m²):", n_cel_p, "\n")
        cat("Pontos por m² (primeiros retornos / área ocupada por primeiros retornos):", round(ppd, 0), "\n")
        cat("Distância linear entre primeiros retornos em m (Nominal Post Spacing):", round(sps, 3), "\n")
        cat("Altura Z bbox (m):", round(alt_bbox, 2), "\n")
        cat("Volume bbox (m³):", vol_bbox, "\n")
        cat("Voxels de 1m³ com pelo menos 1 ponto:", nvoxels, "\n")
        cat("Média de Pontos por Voxel (1m³, exceto vazios):", med_pvox, "\n")
        cat("Mediana de Pontos por Voxel (1m³, exceto vazios):", median_pvox, "\n")
        cat("Desvio padrão de Pontos por Voxel (1m³, exceto vazios):", sd_pvox, "\n")
        cat("Scale Factor:", xscale, yscale, zscale, "\n")
        cat("Offset Value:", xoffset, yoffset, zoffset, "\n")
        cat("Mínimo e Máximo de X:", header@PHB$`Min X`, header@PHB$`Max X`, "\n")
        cat("Mínimo e Máximo de Y:", header@PHB$`Min Y`, header@PHB$`Max Y`, "\n")
        cat("Mínimo e Máximo de Z:", header@PHB$`Min Z`, header@PHB$`Max Z`, "\n \n")
        
        cat("### Intensity ### \n")
        cat("Válido?", if (tem_intensity) "Sim" else "Não", "\n")
        cat("Mínimo e Máximo:", min(las@data$Intensity), max(las@data$Intensity), "\n \n")
        
        cat("### Return Number e Number Of Returns ### \n")
        cat("ReturnNumber válido?", if (tem_return_number) "Sim" else "Não", "\n")
        cat("NumberOfReturns válido?", if (tem_number_of_returns) "Sim" else "Não", "\n")
        cat("Máximo de retornos:", max(las@data$ReturnNumber), "\n")
        cat("Pontos por retorno:", header@PHB$`Number of points by return`, "\n \n")
        
        # Verificações de ScanDirectionFlag, EdgeOfFlightLine e ScanAngleRank
        tem_scan_direction <- "ScanDirectionFlag" %in% names(las@data) && any(las@data$ScanDirectionFlag != 0, na.rm = TRUE)
        tem_edge_flag <- "EdgeOfFlightline" %in% names(las@data) && any(las@data$EdgeOfFlightline != 0, na.rm = TRUE)
        tem_scan_angle <- "ScanAngleRank" %in% names(las@data) && any(las@data$ScanAngleRank != 0, na.rm = TRUE)
        
        cat("### Scan Direction Flag ### \n")
        cat("Válido?", if (tem_scan_direction) "Sim" else "Não", "\n")
        cat("Quantos pontos 0 e 1?", sum(las@data$ScanDirectionFlag == 0), sum(las@data$ScanDirectionFlag == 1), "\n \n")
        
        cat("### Edge Of Flightline ### \n")
        cat("Válido?", if (tem_edge_flag) "Sim" else "Não", "\n")
        cat("Quantos pontos 0 e 1?",sum(las@data$EdgeOfFlightline == 0), sum(las@data$EdgeOfFlightline == 1), "\n \n")
        
        cat("### Scan Angle Rank ### \n")
        cat("Válido?", if (tem_scan_angle) "Sim" else "Não", "\n")
        cat("Mínimo e Máximo:", min(las@data$ScanAngleRank), max(las@data$ScanAngleRank), "\n \n")
        
        cat("### Classification ### \n")
        cat("Pontos classificados? ", if (esta_classificada) "Sim" else "Não", "\n")
        cat("Quais classes? ", unlist(classes_presentes), "\n")
        
        # Estatísticas sobre pontos classificados como chão (2)
        if (esta_classificada) {n_chao <- npoints(solo)
        dens_chao <- if (!is.null(n_chao) && area_bbox > 0) n_chao / area_bbox else NA
        cat("Pontos classificados como chão:", n_chao, "\n")
        cat("Densidade de pontos no chão (pontos/m²):", round(dens_chao, 2), "\n")
        cat("Desvio-padrão da densidade de pontos no chão:", if (!is.na(dens_sd)) round(dens_sd, 2) else "Não aplicável", "\n")
        cat("Mediana Z do solo (m):", if (!is.na(mediana_z_solo)) round(mediana_z_solo, 2) else "Não aplicável", "\n")
        cat("Nuvem normalizada? ", 
            if (is.na(esta_normalizada)) "Não aplicável \n" 
            else if (esta_normalizada) "Sim" else "Não", "\n \n")} else {cat("\n")}   
        
        # Análise PointSourceID: Quantidade de fontes distintas
        if ("PointSourceID" %in% names(las@data)) {
          fontes_id <- unique(na.omit(las@data$PointSourceID))
          qtd_fontes <- length(fontes_id)
        } else {
          qtd_fontes <- NA
        }
        
        # UserData
        tem_userdata <- "UserData" %in% names(las@data) && any(!is.na(las@data$UserData) & las@data$UserData != 0)
        cat("### UserData ### \n")
        cat("Preenchido?", if (tem_userdata) "Sim" else "Não", "\n")
        if (tem_userdata) {cat("Mínimo e Máximo:", min(las@data$UserData), max(las@data$UserData), "\n \n")} else {cat("\n")}
        
        # Verificação GPSTime
        tem_gpstime <- "gpstime" %in% names(las@data) &&
          mean(!is.na(las@data$gpstime) & las@data$gpstime > 0, na.rm = TRUE) > 0.95
        
        cat("### Point Source ID ### \n")
        if (!is.na(qtd_fontes)) {
          if (qtd_fontes > 1) {
            cat("PointSourceID: ", qtd_fontes, " fontes diferentes \n \n")
          } else {
            cat("PointSourceID: Apenas uma fonte \n \n")
          }
        } else {
          cat("PointSourceID: Coluna ausente \n \n")
        }
        cat("### GPS Time ### \n")
        cat("Válido?", if (tem_gpstime) "Sim" else "Não", "\n \n")
        
        # RGB
        cat("### RGB ### \n")
        cat("Possui RGB?", if (tem_rgb_valido) "Sim" else "Não", "\n")
        if (tem_rgb_valido) {cat("RGB parece simulado?", if (simulado_rgb) "Sim" else "Não", "\n")}
      })
    })
    
    diag_corr("diag")
    
  })
  
  output$main_info <- renderUI({
    req(diag_corr())
    if (diag_corr() == "diag") {
      verbatimTextOutput("diag_info")
    } else {
      verbatimTextOutput("hdr_info")
    }
  })
  
  #########################
  #Aba Classificação ruido#
  #########################
  output$parametros_ruidos <- renderUI({
    req(input$algoritmo_ruidos)
    
    if (input$algoritmo_ruidos == "sor") {
      fluidRow(
        column(6,
               numericInput("k", "Quantidade de vizinhos (k)", value = 10),
               numericInput("m", "Multiplicador/Quantil (m)", value = 3)),
        column(6,
               selectInput("quantile", "Quantílico", 
                           choices = c("Sim" = TRUE, "Não" = FALSE), selected = FALSE))
      )
    } else if (input$algoritmo_ruidos == "ivf") {
      fluidRow(
        column(6,
               numericInput("res", "Resolução dos voxels (res)", value = 3)),
        column(6,
               numericInput("n", "Limite (n)", value = 5))
      )
    }
  })
  
  observeEvent(input$classificar_ruidos, {
    req(lasData())
    
    withProgress(message = "Classificando ruídos...", {
      las <- lasData()
      
      if (isTRUE(as.logical(input$quantile))) {
        if (input$m <= 0 || input$m >= 1) {
          showNotification(
            "⚠️ Quando 'Quantílico' está habilitado, o valor de 'm' deve estar entre 0 e 1 (ex: 0.9).",
            type = "error", duration = 8
          )
          return()
        }
      } else {
        if (!is.numeric(input$m) || input$m <= 0) {
          showNotification(
            "⚠️ Quando 'Quantílico' está desativado, o valor de 'm' deve ser um número Racional positivo (ex: 1 ou 2.94).",
            type = "error", duration = 8
          )
          return()
        }
      }
      
      if (input$algoritmo_ruidos == "sor") {
        las_ruidos <- classify_noise(
          las,
          sor(
            k = input$k,
            m = input$m,
            quantile = as.logical(input$quantile)
          )
        )
      } else if (input$algoritmo_ruidos == "ivf") {
        las_ruidos <- classify_noise(
          las,
          ivf(
            res = input$res,
            n = input$n
          )
        )
      }
      lasRuidos(las_ruidos)
    })
    
    showNotification("Classificado!", type = "message")
  })
  
  plot_data <- eventReactive(input$visualizar_ruidos, {
    req(lasRuidos())
    
    withProgress(message = "Processando...", {
      las <- lasRuidos()
      ruidos <- filter_poi(las, Classification == 18)
      nao_ruidos <- filter_poi(las, Classification != 18)
      bbox <- apply(las@data[, c("X", "Y", "Z")], 2, range)
      xlim <- bbox[,"X"]
      ylim <- bbox[,"Y"]
      zlim <- bbox[,"Z"]
      resvx <- (1 / input$ppmc)^(1/3) #
      cor_ruidos <- input$cor_ruidos
      cor_nao_ruidos <- input$cor_nao_ruidos
      mostrar_naoruidos <- input$mostrar_naoruidos
    })
    
    if (npoints(nao_ruidos) > 1e5 && input$subamostrar == TRUE && input$mostrar_naoruidos == TRUE) { 
      withProgress(message = "Subamostrando...", { 
        nao_ruidos <- decimate_points(nao_ruidos, barycenter_per_voxel(res = resvx)) 
        totalpp(npoints(nao_ruidos)) }) 
    } else if (input$mostrar_naoruidos == FALSE) { 
      totalpp(0) 
    } else { 
      totalpp(npoints(las)) 
    }
    
    list(ruidos = ruidos, nao_ruidos = nao_ruidos, xlim = xlim, ylim = ylim,
         zlim = zlim, cor_ruidos = cor_ruidos, cor_nao_ruidos = cor_nao_ruidos,
         mostrar_naoruidos = mostrar_naoruidos)
  })
  
  output$plot_ruidos <- renderRglwidget({
    dados <- plot_data()
    req(dados)
    
    if (is.null(dados) || is.null(lasRuidos())) {
      rgl::open3d(useNULL = TRUE)
      rgl::clear3d()
      return(rglwidget())
    }
    
    ruidos <- dados$ruidos
    nao_ruidos <- dados$nao_ruidos
    xlim <- dados$xlim; ylim = dados$ylim; zlim = dados$zlim
    cor_ruidos <- dados$cor_ruidos
    cor_nao_ruidos <- dados$cor_nao_ruidos
    mostrar_naoruidos <- dados$mostrar_naoruidos
    
    withProgress(message = "Renderizando 3D...", {
      
      open3d()
      bg3d("white")
      par3d(windowRect = c(100, 100, 800, 800))
      
      if (mostrar_naoruidos && npoints(nao_ruidos) > 0) {
        tem_rgb <- all(c("R", "G", "B") %in% names(nao_ruidos@data))
        
        if (cor_nao_ruidos == "rgb" && tem_rgb) {
          rgb_mat <- nao_ruidos@data[, c("R", "G", "B")]
          max_rgb <- max(rgb_mat, na.rm = TRUE)
          divisor <- if (max_rgb > 255) 65535 else 255
          cores <- rgb(rgb_mat$R / divisor, rgb_mat$G / divisor, rgb_mat$B / divisor)
          plot3d(nao_ruidos@data[, c("X", "Y", "Z")], col = cores, size = 1, 
                 add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
        } else {
          plot3d(nao_ruidos@data[, c("X", "Y", "Z")], col = cor_nao_ruidos, 
                 size = 1, add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
        }
        
      } else {
        
        plot3d(ruidos@data[, c("X", "Y", "Z")], col = cor_ruidos, size = 1, 
               add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
        nao_ruidos <- NULL
      }
      
      if (npoints(ruidos) > 0 && !is.null(nao_ruidos)) {
        points3d(ruidos@data[, c("X", "Y", "Z")], col = cor_ruidos, size = 1)
      }
      
      rglwidget()
    })
  })
  
  output$diag_ruidos <- renderUI({
    req(input$aba_ativa == "Classificação de Ruídos")
    req(lasRuidos())
    
    ruidos <- filter_poi(lasRuidos(), Classification == 18)
    if (npoints(ruidos) == 0) return(tags$div("Nenhum ponto classificado como ruído."))
    
    # Estatísticas básicas
    total <- npoints(ruidos)
    perc <- (total / npoints(lasRuidos())) * 100
    perc_formatado <- sprintf("%.2f%%", perc)
    totalp <- npoints(lasRuidos())
    
    fluidRow(
      column(6,
             strong("Pontos ruído:"), br(), total, br(), br(),
             strong("Total de pontos:"), br(), totalp
      ),
      column(6,
             strong("Percentual:"), br(), perc_formatado, br(), br(),
             strong("Pontos não ruído plotados:"), br(), totalpp()
      )
    )
  })
  
  
  observeEvent(input$aplicar_classificacao, {
    req(lasRuidos())
    lasData(lasRuidos())
    
    showNotification("Classificação salva!",
                     type = "message")
  }) 
  
  observeEvent(input$aplicar_classificacao_s_r, {
    req(lasRuidos())
    las_sem_ruido <- filter_poi(lasRuidos(), Classification != 18)
    lasData(las_sem_ruido)
    
    showNotification("Ruídos excluídos!",
                     type = "message")
  })
  
  observeEvent(input$limpar_memoria_r, {
    lasRuidos(NULL)
    gc()
    try(rgl::clear3d(), silent = TRUE)
    try(rgl::close3d(), silent = TRUE)
    showNotification("Memória liberada",
                     type = "message")
  })
  
  output$salvar_las_r <- downloadHandler(
    filename = function() {
      if (input$comprimir) {
        paste0("arquivo_", Sys.Date(), ".laz")
      } else {
        paste0("arquivo_", Sys.Date(), ".las")
      }
    },
    content = function(file) {
      req(lasData())
      las <- lasData()
      writeLAS(las, file)
    }
  )
  
  #######################      
  #Aba Classificação Chão
  #######################
  
  output$parametros_algo <- renderUI({
    req(input$algoritmo_solo)
    
    if (input$algoritmo_solo == "csf") {
      fluidRow(
        column(6,
               selectInput("sloop_smooth", "Encosta íngreme", choices = c("Sim" = TRUE, "Não" = FALSE), selected = FALSE),
               textInput("class_threshold", "Limite distância vertical", value = 0.5),
               textInput("cloth_resolution", "Resolução pano", value = 0.5)
        ),
        column(6,
               selectInput("rigidness", "Rigidez", 
                           choices = c("Flexível" = 1, "Médio" = 2, "Rígido" = 3), selected = 1),
               numericInput("iterations", "Iterações", value = 500, min = 1, step = 1),
               textInput("time_step", "Distância passo", value = 0.65)
        )
      )
    } else if (input$algoritmo_solo == "pmf") {
      fluidRow(
        column(6,
               textInput("pmf_ws", "Tamanho Janela (ws)",
                         value = "3,6,9,12")
        ),
        column(6,
               textInput("pmf_th", "Limite (th)",
                         value = "0.1,0.3,0.5,1")
        )
      )
    } else if (input$algoritmo_solo == "mcc") {
      fluidRow(
        column(6,
               textInput("mcc_s", "Tamanho da janela (s)",
                         value = 1.5)),
        column(6,
               textInput("mcc_t", "Limite de curvatura (t)",
                         value = 0.3))
      )
    }
  })
  
  parse_seq <- function(txt) {
    vals <- unlist(strsplit(txt, "[,;\\s]+"))   # aceita vírgula, ponto-e-vírgula ou espaços
    vals <- trimws(vals)
    vals <- vals[vals != ""]
    nums <- as.numeric(vals)
    if (any(is.na(nums))) stop("Sequência contém valores não numéricos")
    nums
  }
  
  observeEvent(input$classificar_chao, {
    req(lasData())
    
    withProgress(message = "Classificando chão...", {
      las <- lasData()
      
      if (input$algoritmo_solo == "csf") {
        
        las_classificado <- classify_ground(
          las,
          csf(
            sloop_smooth = as.logical(input$sloop_smooth),
            class_threshold = as.numeric(input$class_threshold),
            cloth_resolution = as.numeric(input$cloth_resolution),
            rigidness = as.integer(input$rigidness),
            iterations = as.integer(input$iterations),
            time_step = as.numeric(input$time_step)
          )
        )
        
      } else if (input$algoritmo_solo == "pmf") {
        
        ws_vals <- tryCatch(parse_seq(input$pmf_ws),
                            error = function(e) { showNotification(paste("Erro em ws:", e$message), type = "error"); return(NULL) })
        if (is.null(ws_vals)) return()
        
        th_vals <- tryCatch(parse_seq(input$pmf_th),
                            error = function(e) { showNotification(paste("Erro em th:", e$message), type = "error"); return(NULL) })
        if (is.null(th_vals)) return()
        
        # se o usuário forneceu apenas 1 threshold, repetir para cada ws
        if (length(th_vals) == 1) {
          th_vals <- rep(th_vals, length(ws_vals))
        }
        
        if (length(th_vals) != length(ws_vals)) {
          showNotification("Quantidade de thresholds deve ser 1 ou igual ao comprimento de ws.", type = "error")
          return()
        }
        
        las_classificado <- classify_ground(las, pmf(ws = ws_vals, th = th_vals))
      } else if (input$algoritmo_solo == "mcc") {
        las_classificado <- classify_ground(
          las, mcc(
            s = as.numeric(input$mcc_s),
            t = as.numeric(input$mcc_t)
          )
        )
      }
      lasSoloClassificado(las_classificado)
    })
    showNotification("Classificado!", type = "message")
  })
  
  plot_data_c <- eventReactive(input$visualizar_solo, {
    req(lasSoloClassificado())
    
    withProgress(message = "Processando...", {
      las <- lasSoloClassificado()
      not_ground <- filter_poi(las, Classification != 2)
      ground <- filter_poi(las, Classification == 2)
      bbox <- apply(las@data[, c("X", "Y", "Z")], 2, range)
      xlim <- bbox[,"X"]
      ylim <- bbox[,"Y"]
      zlim <- bbox[,"Z"]
      resvx <- (1 / input$ppmc_c)^(1/3)
      cor_chao <- input$cor_chao
      cor_nao_chao <- input$cor_nao_chao
      mostrar_outros <- input$mostrar_outros
    })
    
    if (npoints(not_ground) > 1e5 && input$subamostrar_chao == TRUE && input$mostrar_outros == TRUE) {
      withProgress(message = "Subamostrando...", {
        not_ground <- decimate_points(not_ground, barycenter_per_voxel(res = resvx))
        totalppc(npoints(not_ground))
      })
    } else if (input$mostrar_outros == FALSE) {
      totalppc(0)
    } else {
      totalppc(npoints(not_ground))
    }
    
    list(ground = ground, not_ground = not_ground, xlim = xlim, ylim = ylim,
         zlim = zlim, cor_chao = cor_chao, cor_nao_chao = cor_nao_chao,
         mostrar_outros = mostrar_outros)
  })
  
  output$plot_mdt <- renderRglwidget({
    dados <- plot_data_c()
    req(dados)
    
    if (is.null(dados) || is.null(lasSoloClassificado())) {
      rgl::open3d(useNULL = TRUE)
      rgl::clear3d()
      return(rgl::rglwidget())
    }
    
    ground <- dados$ground
    not_ground <- dados$not_ground
    xlim <- dados$xlim; ylim = dados$ylim; zlim = dados$zlim
    cor_chao <- dados$cor_chao
    cor_nao_chao <- dados$cor_nao_chao
    mostrar_outros <- dados$mostrar_outros
    
    withProgress(message = "Renderizando 3D...", {
      
      open3d()
      bg3d("white")
      par3d(windowRect = c(100, 100, 800, 800))
      
      if (input$mostrar_outros && npoints(not_ground) > 0) {
        
        tem_rgb <- all(c("R", "G", "B") %in% names(not_ground@data))
        
        if (cor_nao_chao == "rgb" && tem_rgb) {
          rgb_mat <- not_ground@data[, c("R", "G", "B")]
          max_rgb <- max(rgb_mat, na.rm = TRUE)
          divisor <- if (max_rgb > 255) 65535 else 255
          cores <- rgb(rgb_mat$R / divisor, rgb_mat$G / divisor, rgb_mat$B / divisor)
          plot3d(not_ground@data[, c("X", "Y", "Z")], col = cores, size = 1, 
                 add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
        } else {
          plot3d(not_ground@data[, c("X", "Y", "Z")], col = cor_nao_chao, 
                 size = 1, add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
        }
        
      } else {
        
        plot3d(ground@data[, c("X", "Y", "Z")], col = cor_chao, size = 1, 
               add = FALSE, xlim = xlim, ylim = ylim, zlim = zlim)
        not_ground <- NULL
      }
      
      if (npoints(ground) > 0 && !is.null(not_ground)) {
        points3d(ground@data[, c("X", "Y", "Z")], col = cor_chao, size = 1)
      }
      
      rglwidget()
    })
  })
  
  output$diag_solo_classificado <- renderUI({
    req(input$aba_ativa == "Classificação do Chão")
    req(lasSoloClassificado())
    
    solo <- filter_poi(lasSoloClassificado(), Classification == 2)
    if (npoints(solo) == 0) return(tags$div("Nenhum ponto classificado como chão."))
    
    # Estatísticas básicas
    total <- npoints(solo)
    zmax <- max(solo@data$Z, na.rm = TRUE)
    zmin <- min(solo@data$Z, na.rm = TRUE)
    amplitude <- zmax - zmin
    
    # Cálculo da densidade e seu desvio padrão
    dens <- grid_density(solo, res = 1)
    media <- mean(values(dens), na.rm = TRUE)
    median <- median(values(dens), na.rm = TRUE)
    desvio <- sd(values(dens), na.rm = TRUE)
    
    fluidRow(
      column(6,
             strong("Pontos chão:"), br(), total, br(), br(),
             strong("Z máx:"), br(), round(zmax, 2), br(), br(),
             strong("Z mín:"), br(), round(zmin, 2), br(), br(),
             strong("Total de pontos não chão plotados:"), br(), totalppc()
      ),
      column(6,
             strong("Z amplitude:"), br(), round(amplitude, 2), br(), br(),
             strong("Média/m²:"), br(), round(media, 2), br(), br(),
             strong("Mediana/m²"), br(), round(median, 2), br(), br(),
             strong("Desvio/m²:"), br(), round(desvio, 2)
      )
    )
  })
  
  observeEvent(input$aplicar_classificacao, {
    req(lasSoloClassificado())
    lasData(lasSoloClassificado())
    
    showNotification("Classificação salva!",
                     type = "message")
  })
  
  observeEvent(input$limpar_memoria_c, {
    lasSoloClassificado(NULL)
    gc()
    try(rgl::clear3d(), silent = TRUE)
    try(rgl::close3d(), silent = TRUE)
    showNotification("Memória liberada",
                     type = "message")
  })
  
  output$salvar_las_c <- downloadHandler(
    filename = function() {
      if (input$comprimir) {
        paste0("arquivo_", Sys.Date(), ".laz")
      } else {
        paste0("arquivo_", Sys.Date(), ".las")
      }
    },
    content = function(file) {
      req(lasData())
      las <- lasData()
      writeLAS(las, file)
    }
  )
  
  output$salvar_las_cpc <- downloadHandler(
    filename = function() {
      ext <- if (input$comprimir) ".laz" else ".las"
      paste0("nuvem_solo_", Sys.Date(), ext)
    },
    content = function(file) {
      req(lasData())
      las <- lasData()
      
      las_solo <- lidR::filter_poi(las, Classification == 2L)
      
      if (nrow(las_solo@data) == 0) {
        showNotification("Nenhum ponto classificado como solo (classe 2) foi encontrado.", type = "error")
        return(NULL)
      }
      
      lidR::writeLAS(las_solo, file)
    }
  )
  
  output$salvar_las_cv <- downloadHandler(
    filename = function() {
      ext <- if (input$comprimir) ".laz" else ".las"
      paste0("nuvem_solo_", Sys.Date(), ext)
    },
    content = function(file) {
      req(lasData())
      las <- lasData()
      
      las_solo <- lidR::filter_poi(las, Classification != 2L)
      
      if (nrow(las_solo@data) == 0) {
        showNotification("Nenhum ponto classificado como solo (classe 2) foi encontrado.", type = "error")
        return(NULL)
      }
      
      lidR::writeLAS(las_solo, file)
    }
  )
  #########      
  #Aba MDT#
  #########
  
  output$parametros_mdt <- renderUI({
    req(input$algoritmo_mdt)
    
    if (input$algoritmo_mdt == "idw") {
      tagList(
        numericInput("idw_res", "Resolução da malha (grid)", value = 1, step = 1),
        fluidRow(
          column(6,
                 numericInput("idw_k", "Quantidade de vizinhos (k)", value = 10, step = 1),
                 numericInput("idw_p", "Expoente (p)", value = 2, step = 1)),
          column(6,
                 numericInput("idw_rmax", "Raio máximo (rmax)", value = 50, step = 1))
        )
      )
    } else if (input$algoritmo_mdt == "tin") {
      tagList(
        numericInput("tin_res", "Resolução da malha (grid)", value = 1, step = 1),
        radioButtons("alterar_extrap", "Alterar parâmetros da Extrapolação?",
                     choices = c("Sim", "Não"), selected = "Não"),
        
        conditionalPanel(
          condition = "input.alterar_extrap == 'Sim'",
          fluidRow(
            column(6,
                   numericInput("tin_k", "Quantidade de vizinhos (k)", value = 3, step = 1),
                   numericInput("tin_p", "Expoente (p)", value = 2)),
            column(6,
                   numericInput("tin_rmax", "Raio máximo (rmax)", value = 50, step = 1))
          )
        )
      )
    } else if (input$algoritmo_mdt == "krig") {
      tagList(
        numericInput("res_krig", "Resolução da malha (grid)", value = 1, step = 1),
        numericInput("k_krig", "Quantidade de vizinhos (k)", value = 10, step = 1)
      )
    }
  })
  
  observeEvent(input$gerar_mdt, {
    req(lasData())
    req(input$algoritmo_mdt)
    las <- lasData()
    
    withProgress(message = "Gerando MDT...", {
      
      chao <- filter_poi(las, Classification == 2)
      
      if (npoints(chao) == 0) {
        showNotification("Nenhum ponto de solo encontrado. Não foi possível gerar o MDT.",
                         type = "error")
        return(NULL)
      }
      
      if (input$algoritmo_mdt == "idw") {
        mdt_calc <- rasterize_terrain(
          las,
          res = input$idw_res,
          knnidw(k = as.integer(input$idw_k),
                 p = input$idw_p,
                 rmax = input$idw_rmax)
        )
      } else if (input$algoritmo_mdt == "tin" && input$alterar_extrap == "Não") {
        mdt_calc <- rasterize_terrain(
          las,
          res = input$tin_res,
          tin()
        )
      } else if (input$algoritmo_mdt == "tin" && input$alterar_extrap == "Sim") {
        mdt_calc <- rasterize_terrain(
          las,
          res = input$tin_res,
          tin(extrapolate = knnidw(
            k = as.integer(input$tin_k),
            p = input$tin_p,
            rmax = input$tin_rmax
          ))
        )
      } else if (input$algoritmo_mdt == "krig") {
        mdt_calc <- rasterize_terrain(
          las,
          res = input$res_krig,
          kriging(model = NULL, k = as.integer(input$k_krig))
        )
      }
      mdt(mdt_calc)
    })
  })
  
  output$plot_mdtn <- renderRglwidget({
    req(mdt())
    tmdt <- mdt()
    
    if (is.null(tmdt)) {
      rgl::open3d(useNULL = TRUE)
      rgl::clear3d()
      return(rgl::rglwidget())
    }
    
    withProgress(message = "Renderizando 3D...", {
      plot_dtm3d(mdt(), bg = "white")
      rglwidget()
    })
  })
  
  output$diag_norm <- renderUI({
    req(input$aba_ativa == "MDS, Normalização e CHM")
    vals <- diag_norm_vals()
    req(vals)
    
    tagList(
      fluidRow(
        column(6, 
               strong("Z máx:"), br(), vals$zmax, br(), br(),
               strong("Z médio:"), br(), round(vals$zmed, 3), br(), br(),
               strong("Pontos degenerados:"), br(), vals$degp),
        column(6, 
               strong("Z min:"), br(), round(vals$zmin, 4), br(), br(),
               strong("Z amplitude:"), br(), vals$zamp)
      ),
      
      fluidRow(
        column(12,
               plotlyOutput("hist_chao_plotly", height = "300px"))
      )
    )
  })
  
  mdt_metricas <- reactive({
    req(mdt())
    
    vals <- terra::values(mdt())
    tam_vals <- length(vals)
    invalid_vals <- sum(is.na(vals))
    perc_inv_vals <- invalid_vals / tam_vals * 100
    
    min_vals <- min(vals, na.rm = TRUE)
    max_vals <- max(vals, na.rm = TRUE)
    ampl_vals <- max_vals - min_vals
    
    list(tam_vals = tam_vals,
         invalid_vals = invalid_vals,
         perc_inv_vals = perc_inv_vals,
         min_vals = min_vals,
         max_vals = max_vals,
         ampl_vals = ampl_vals)
  })
  
  output$diag_mdt <- renderUI({
    m <- mdt_metricas()
    
    tagList(
      fluidRow(
        column(6,
               strong("Quantidade de pixels:"), br(), m$tam_vals, br(), br(),
               strong("Quantidade de píxels inválidos:"), br(), m$invalid_vals, br(), br(),
               strong("Percentual de píxels inválidos:"), br(), round(m$perc_inv_vals,2)),
        column(6,
               strong("Z máx:"), br(), round(m$max_vals,2), br(), br(),
               strong("Z mín:"), br(), round(m$min_vals, 2), br(), br(),
               strong("Z amplitude:"), br(), round(m$ampl_vals, 2))
      )
    )
  })
  
  output$baixar_mdt <- downloadHandler(
    filename = function() {
      paste0("mdt_", Sys.Date(), ".tif")
    },
    content = function(file) {
      req(mdt())
      
      raster::writeRaster(mdt(), file, filetype = "GTiff", overwrite = TRUE)
    }
  )
  
  observeEvent(input$limpar_memoria_s, {
    mdt(NULL)
    gc()
    showNotification("Memória liberada",
                     type = "message")
  })
  
  #########      
  #Aba MDS#
  #########
  
  observeEvent(input$aplicar_normalizacao, {
    req(lasData())
    req(mdt())
    
    withProgress(message = "Normalizando...", {
      lasn <- normalize_height(lasData(), mdt())
      lasNormalizado(lasn)
      showNotification("Normalizado.",
                       type = "message")
    })
  })
  
    observeEvent(input$aplicar_normalizacao, {
    req(lasData())
    req(mdt())
    
    withProgress(message = "Normalizando...", {
      lasn <- normalize_height(lasData(), mdt())
      lasNormalizado(lasn)
      showNotification("Normalizado.",
                       type = "message")
    })
  })
  
  diag_norm_vals <- eventReactive(input$aplicar_normalizacao, {
    req(lasNormalizado(), mdt())
    chao <- filter_poi(lasNormalizado(), Classification == 2)
    if (npoints(chao) == 0) return("Nenhum ponto classificado como chão")
    
    list(
      zmax = max(chao@data$Z, na.rm = TRUE),
      zmin = min(chao@data$Z, na.rm = TRUE),
      zmed = mean(chao@data$Z, na.rm = TRUE),
      degp = sum(duplicated(chao@data[, c("X", "Y")])),
      zamp = max(chao@data$Z, na.rm = TRUE) - min(chao@data$Z, na.rm = TRUE)
    )
  })
  
  output$hist_chao_plotly <- renderPlotly({
    req(input$aplicar_normalizacao)
    req(lasNormalizado())
    
    chao <- filter_poi(lasNormalizado(), Classification == 2)
    req(npoints(chao) > 0)
    
    plot_ly(
      x = chao@data$Z,
      type = "histogram",
      nbinsx = 30,
      marker = list(color = 'skyblue')
    ) %>%
      layout(
        title = "Histograma de alturas do chão (normalizado)",
        xaxis = list(title = "Altura (m)"),
        yaxis = list(title = "Frequência")
      )
  })
  
  output$parametros_mds <- renderUI({
    req(input$algoritmo_mds)
    
    if(input$algoritmo_mds == "pf") {
      tagList(
        numericInput("res", "Resolução da malha (grid)", value = 1, step = 1),
        fluidRow(
          column(6,
                 textInput("th", "Limiares de corte vertical", value = "0,5,10,20,30"),
                 textInput("me", "Máximo lado do triângulo", value = "0,1")),
          column(6,
                 numericInput("sb", "Raio do círculo", value = 0, step = 0.1),
                 div(style = "display: flex; align-items: center; position: relative;",
                     checkboxInput("h", "Ponto mais alto por pixel", value = TRUE),
                     span(
                       icon("info-circle"), 
                       id = "ajuda_h", 
                       style = "color: #b5b5b5; cursor: help; margin-left: -10px; margin-bottom: 10px; font-size: 0.9em; z-index: 999; pointer-events: auto;"
                     )
                 ),
                 bsTooltip(
                   id = "ajuda_h", 
                   title = "Se ativado, utiliza apenas o ponto mais alto de cada pixel, acelerando o processamento. Se desativado, utiliza todos os primeiros retornos.",
                   placement = "top", 
                   trigger = "hover"
                 )
          )
        )
      )
    } else if (input$algoritmo_mds == "p2r") {
      tagList(
        numericInput("res", "Resolução da malha (grid)", value = 1, step = 1),
        fluidRow(
          column(6,
                 numericInput("sb", "Raio do círculo", value = 0, step = 0.1),
          ),
          column(6,
                 selectInput("fill", "Função de interpolação", 
                             choices = c("Nenhum" = "none", "KNN-IDW" = "knnidw", "TIN" = "tin", "Krigagem" = "kriging"),
                             selected = "none"))
        )
      )
    } else if (input$algoritmo_mds == "tin") {
      tagList(
        numericInput("res", "Resolução da malha (grid)", value = 1, step = 1),
        fluidRow(
          column(6,
                 numericInput("me", "Máximo lado do triângulo", value = 2)),
          column(6,
                 div(style = "display: flex; align-items: center; position: relative;",
                     checkboxInput("h", "Ponto mais alto por pixel", value = TRUE),
                     span(
                       icon("info-circle"), 
                       id = "ajuda_h", 
                       style = "color: #b5b5b5; cursor: help; margin-left: -10px; margin-bottom: 10px; font-size: 0.9em; z-index: 999; pointer-events: auto;"
                     )
                 ),
                 bsTooltip(
                   id = "ajuda_h", 
                   title = "Se ativado, utiliza apenas o ponto mais alto de cada pixel, acelerando o processamento. Se desativado, utiliza todos os primeiros retornos.",
                   placement = "top", 
                   trigger = "hover"
                 )
          )
        )
      )
    }
  })
  
  parse_seq <- function(txt) {
    vals <- unlist(strsplit(txt, "[,;\\s]+"))   # aceita vírgula, ponto-e-vírgula ou espaços
    vals <- trimws(vals)
    vals <- vals[vals != ""]
    nums <- as.numeric(vals)
    if (any(is.na(nums))) stop("Sequência contém valores não numéricos")
    nums
  }
  
  observeEvent(input$gerar_mds, {
    req(lasData())
    las <- lasData()
    
    tem_return_number <- "ReturnNumber" %in% names(las@data) &&
      mean(!is.na(las@data$ReturnNumber) & las@data$ReturnNumber > 0) > 0.95
    
    if (input$algoritmo_mds %in% c("pf", "tin") && !tem_return_number) {
      showNotification(
        "⚠️ A nuvem de pontos não possui valores válidos de 'ReturnNumber'. 
        Os algoritmos Pit-free e TIN exigem retornos válidos (first returns). 
        Use o método 'p2r' para nuvens sem esta informação.",
        type = "error", duration = 10
      )
      return()
    }
    
    if (input$algoritmo_mds %in% "tin" && input$res >= input$me) {
      showNotification(
        "⚠ Neste algoritmo o lado máximo do triângulo não pode ser igual ou menor que a resolução escolhida.",
        type = "error", duration = 10
      )
      return()
    }
    
    withProgress(message = "Gerando MDS / CHM...", {
      
      if (input$algoritmo_mds == "pf") {
        th_v <- tryCatch(parse_seq(input$th),
                         error = function(e) {showNotification(paste("Erro em th:", e$message), type = "error"); return(NULL) })
        if (is.null(th_v)) return()
        me_v <- tryCatch(parse_seq(input$me),
                         error = function(e) {showNotification(paste("Erro em me:", e$message), type = "error"); return(NULL) })
        if (is.null(me_v)) return()
        mds_calc <- tryCatch({
          rasterize_canopy(las, res = input$res,
                           pitfree(thresholds = th_v, max_edge = me_v, 
                                   subcircle = input$sb, highest = as.logical(input$h))
          )
        })
        
      } else if (input$algoritmo_mds == "p2r") {
        na_fill <- switch(input$fill,
                          "none"    = NULL,
                          "knnidw"  = lidR::knnidw(),  
                          "tin"     = lidR::tin(),     
                          "kriging" = lidR::kriging())  
        
        mds_calc <- rasterize_canopy(
          las,
          res = input$res,
          p2r(subcircle = input$sb, na.fill = na_fill)
        )
        
      } else if (input$algoritmo_mds == "tin") {
        mds_calc <- rasterize_canopy(
          las,
          res = input$res,
          dsmtin(max_edge = input$me, highest = as.logical(input$h))
        )
      }
      mds(mds_calc)
    })
  })
  
  output$plot_mds <- renderRglwidget({
    req(mds())
    
    withProgress(message = "Renderizando 3D...", {
      plot_dtm3d(mds(), bg = "white")
      rglwidget()
    })
  })
  
  mds_metricas <- reactive({
    req(mds())
    
    vals <- terra::values(mds())
    tam_vals <- length(vals)
    invalid_vals <- sum(is.na(vals))
    perc_inv_vals <- invalid_vals / tam_vals * 100
    
    min_vals <- min(vals, na.rm = TRUE)
    max_vals <- max(vals, na.rm = TRUE)
    ampl_vals <- max_vals - min_vals
    
    list(tam_vals = tam_vals,
         invalid_vals = invalid_vals,
         perc_inv_vals = perc_inv_vals,
         min_vals = min_vals,
         max_vals = max_vals,
         ampl_vals = ampl_vals)
  })
  
  output$diag_mds <- renderUI({
    m <- mds_metricas()
    
    tagList(
      fluidRow(
        column(6,
               strong("Quantidade de pixels:"), br(), m$tam_vals, br(), br(),
               strong("Quantidade de píxels inválidos:"), br(), m$invalid_vals, br(), br(),
               strong("Percentual de píxels inválidos:"), br(), round(m$perc_inv_vals, 2)),
        column(6,
               strong("Z máx:"), br(), round(m$max_vals,2), br(), br(),
               strong("Z mín:"), br(), round(m$min_vals, 2), br(), br(),
               strong("Z amplitude:"), br(), round(m$ampl_vals, 2))
      )
    )
  })
  
  output$baixar_mds <- downloadHandler(
    filename = function() {
      paste0("mds_", Sys.Date(), ".tif")
    },
    content = function(file) {
      req(mds())
      
      raster::writeRaster(mds(), file, filetype = "GTiff", overwrite = TRUE)
    }
  )
  
  observeEvent(input$salvar_norm, {
    req(lasData())
    req(lasNormalizado())
    
    withProgress(message = "Salvando normalização...", {
      lasData(lasNormalizado())
      showNotification("Salvo.",
                       type = "message")
    })  
  })
  
  output$salvar_las_n <- downloadHandler(
    filename = function() {
      if (input$comprimir) {
        paste0("arquivo_", Sys.Date(), ".laz")
      } else {
        paste0("arquivo_", Sys.Date(), ".las")
      }
    },
    content = function(file) {
      req(lasData())
      las <- lasData()
      writeLAS(las, file)
    })
  
  observeEvent(input$limpar_memoria_mds, {
    mds(NULL)
    gc()
    showNotification("Memória liberada",
                     type = "message")
  })
}

shinyApp(ui, server)
